#include <gtest/gtest.h>

#include <filesystem>
#include <map>
#include <string>
#include <vector>

#include "class_macro.hpp"
#include "file_helper.hpp"

#include "vpg_enum_class.hpp"
#include "vpg_enum_class_reader.hpp"
#include "vpg_file_generation_manager.hpp"
#include "vpg_global.hpp"
#include "vpg_property_accessor_generation_service.hpp"

// same as TEST_F(VPGVccGenerationManagerTest, XXX)
// need to change TEST_F(VPGVccGenerationManagerTest, XXX)
class VPGPropertyAccessorFileGenerationServiceTest : public testing::Test 
{
    GETSET_SPTR_NULL(vcc::LogConfig, LogConfig);
    GETSET(std::wstring, Workspace, L"bin/Debug/VPGPropertyAccessorFileGenerationServiceTest/");
    
    GETSET(std::wstring, FilePathHpp, L"");
    GETSET(std::wstring, FilePathCpp, L"");
    GETSET(std::wstring, IncludeFileName, L"");

    MAP(std::wstring, std::wstring, ProjectIncludeList);
    public:
        void SetUp() override
        {
            this->_LogConfig = std::make_shared<vcc::LogConfig>();
            this->_LogConfig->setIsConsoleLog(false);
            std::filesystem::remove_all(PATH(this->getWorkspace()));

            this->_FilePathHpp = vcc::concatPaths({this->getWorkspace(), L"vpg_object_property_accessor.hpp"});
            this->_FilePathCpp = vcc::concatPaths({this->getWorkspace(), L"vpg_object_property_accessor.cpp"});
            this->_IncludeFileName = L"vpg_object_property_accessor.hpp";

            this->insertProjectIncludeListAtKey(L"VCCEnum", L"vcc_enum.hpp");
            this->insertProjectIncludeListAtKey(L"VPGObject", L"vpg_object.hpp");
            this->insertProjectIncludeListAtKey(L"VPGObjectProperty", L"vpg_object_property.hpp");
            this->insertProjectIncludeListAtKey(L"VPGObjectA", L"vpg_object_a.hpp");
            this->insertProjectIncludeListAtKey(L"VPGObjectAProperty", L"vpg_object_a_property.hpp");
            this->insertProjectIncludeListAtKey(L"VPGObjectB", L"vpg_object_b.hpp");
            this->insertProjectIncludeListAtKey(L"VPGObjectBProperty", L"vpg_object_b_property.hpp");
        }

        void TearDown() override
        {
            std::filesystem::remove_all(PATH(this->getWorkspace()));
        }
};

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, Single)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    Bool, // GETSET(bool, Bool, false)\r\n"
        "    String, // GETSET(std::string, String, \"\")\r\n"
        "    Wstring, // GETSET(std::wstring, Wstring, L\"\")\r\n"
        "    Enum // GETSET(VCCEnum, Enum, VCCEnum::VCCEnumA)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->getLogConfig().get(), L"VPG", this->getFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->getLogConfig().get(), L"VPG", this->getProjectIncludeList(), this->getFilePathCpp(), enumClassList);
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathHpp()));
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include <string>\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(bool, Bool)\r\n"
    "    PROPERTY_ACCESSOR_HEADER(long, Long)\r\n"
    "    PROPERTY_ACCESSOR_HEADER(std::wstring, String)\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->getIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include <string>\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vcc_enum.hpp\"\r\n"
    "#include \"vpg_object.hpp\"\r\n"
    "#include \"vpg_object_property.hpp\"\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_readBool(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Bool:\r\n"
    "            return obj->getBool();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_readBoolAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_readBoolAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeBool(const int64_t &objectProperty, const bool &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Bool:\r\n"
    "            obj->setBool(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeBoolAtKey(const int64_t &objectProperty, const bool &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "long VPGObjectPropertyAccessor::_readLong(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Enum:\r\n"
    "            return static_cast<long>(obj->getEnum());\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0L;\r\n"
    "}\r\n"
    "\r\n"
    "long VPGObjectPropertyAccessor::_readLongAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return 0L;\r\n"
    "}\r\n"
    "\r\n"
    "long VPGObjectPropertyAccessor::_readLongAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return 0L;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeLong(const int64_t &objectProperty, const long &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Enum:\r\n"
    "            obj->setEnum(static_cast<VCCEnum>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeLongAtIndex(const int64_t &objectProperty, const long &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeLongAtKey(const int64_t &objectProperty, const long &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertLongAtIndex(const int64_t &objectProperty, const long &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::wstring VPGObjectPropertyAccessor::_readString(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::String:\r\n"
    "            return vcc::str2wstr(obj->getString());\r\n"
    "        case VPGObjectProperty::Wstring:\r\n"
    "            return obj->getWstring();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return L\"\";\r\n"
    "}\r\n"
    "\r\n"
    "std::wstring VPGObjectPropertyAccessor::_readStringAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return L\"\";\r\n"
    "}\r\n"
    "\r\n"
    "std::wstring VPGObjectPropertyAccessor::_readStringAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return L\"\";\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeString(const int64_t &objectProperty, const std::wstring &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::String:\r\n"
    "            obj->setString(wstr2str(value));\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Wstring:\r\n"
    "            obj->setWstring(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeStringAtKey(const int64_t &objectProperty, const std::wstring &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, Namespace)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectAProperty\r\n"
        "{\r\n"
        "    EnumA // GETSET(std::wstring, EnumA, L\"\")\r\n"
        "};\r\n"
        "\r\n"
        "namespace NamespaceA {\r\n"
        "    enum class VPGObjectNamespaceProperty\r\n"
        "    {\r\n"
        "        EnumA // GETSET(std::wstring, EnumA, L\"\")\r\n"
        "    };\r\n"
        "    namespace NamespaceNested {\r\n"
        "        enum class VPGObjectNamespaceNestedProperty\r\n"
        "        {\r\n"
        "            EnumA // GETSET(std::wstring, EnumA, L\"\")\r\n"
        "        };\r\n"
        "    }\r\n"
        "};"
        "\r\n"
        "enum class VPGObjectBProperty\r\n"
        "{\r\n"
        "    EnumA // GETSET(std::wstring, EnumA, L\"\")\r\n"
        "};\r\n"
        "\r\n"
        "namespace NamespaceB {\r\n"
        "    enum class VPGObjectNamespaceProperty\r\n"
        "    {\r\n"
        "        EnumA // GETSET(std::wstring, EnumA, L\"\")\r\n"
        "    };\r\n"
        "    namespace NamespaceNested {\r\n"
        "        enum class VPGObjectNamespaceNestedProperty\r\n"
        "        {\r\n"
        "            EnumA // GETSET(std::wstring, EnumA, L\"\")\r\n"
        "        };\r\n"
        "    }\r\n"
        "};"
        "\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    this->insertProjectIncludeListAtKey(L"NamespaceA::VPGObjectNamespace", L"vcc_enum.hpp");
    this->insertProjectIncludeListAtKey(L"NamespaceA::VPGObjectNamespaceProperty", L"vcc_enum.hpp");
    this->insertProjectIncludeListAtKey(L"NamespaceA::NamespaceNested::VPGObjectNamespaceNested", L"vcc_enum.hpp");
    this->insertProjectIncludeListAtKey(L"NamespaceA::NamespaceNested::VPGObjectNamespaceNestedProperty", L"vcc_enum.hpp");
    this->insertProjectIncludeListAtKey(L"NamespaceB::VPGObjectNamespace", L"vcc_enum.hpp");
    this->insertProjectIncludeListAtKey(L"NamespaceB::VPGObjectNamespaceProperty", L"vcc_enum.hpp");
    this->insertProjectIncludeListAtKey(L"NamespaceB::NamespaceNested::VPGObjectNamespaceNested", L"vcc_enum.hpp");
    this->insertProjectIncludeListAtKey(L"NamespaceB::NamespaceNested::VPGObjectNamespaceNestedProperty", L"vcc_enum.hpp");
    VPGPropertyAccessorGenerationService::GenerateHpp(this->getLogConfig().get(), L"VPG", this->getFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->getLogConfig().get(), L"VPG", this->getProjectIncludeList(), this->getFilePathCpp(), enumClassList);
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathHpp()));
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include <string>\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "class VPGObjectAPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(std::wstring, String)\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectAPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectAPropertyAccessor() {}\r\n"
    "};\r\n"
    "\r\n"
    "class VPGObjectBPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(std::wstring, String)\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectBPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectBPropertyAccessor() {}\r\n"
    "};\r\n"
    "\r\n"
    "namespace NamespaceA\r\n"
    "{\r\n"
    "    class VPGObjectNamespacePropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "    {\r\n"
    "        PROPERTY_ACCESSOR_HEADER(std::wstring, String)\r\n"
    "\r\n"
    "        public:\r\n"
    "            VPGObjectNamespacePropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "            virtual ~VPGObjectNamespacePropertyAccessor() {}\r\n"
    "    };\r\n"
    "\r\n"
    "    namespace NamespaceNested\r\n"
    "    {\r\n"
    "        class VPGObjectNamespaceNestedPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "        {\r\n"
    "            PROPERTY_ACCESSOR_HEADER(std::wstring, String)\r\n"
    "\r\n"
    "            public:\r\n"
    "                VPGObjectNamespaceNestedPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "                virtual ~VPGObjectNamespaceNestedPropertyAccessor() {}\r\n"
    "        };\r\n"
    "    }\r\n"
    "}\r\n"
    "\r\n"
    "namespace NamespaceB\r\n"
    "{\r\n"
    "    class VPGObjectNamespacePropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "    {\r\n"
    "        PROPERTY_ACCESSOR_HEADER(std::wstring, String)\r\n"
    "\r\n"
    "        public:\r\n"
    "            VPGObjectNamespacePropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "            virtual ~VPGObjectNamespacePropertyAccessor() {}\r\n"
    "    };\r\n"
    "\r\n"
    "    namespace NamespaceNested\r\n"
    "    {\r\n"
    "        class VPGObjectNamespaceNestedPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "        {\r\n"
    "            PROPERTY_ACCESSOR_HEADER(std::wstring, String)\r\n"
    "\r\n"
    "            public:\r\n"
    "                VPGObjectNamespaceNestedPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "                virtual ~VPGObjectNamespaceNestedPropertyAccessor() {}\r\n"
    "        };\r\n"
    "    }\r\n"
    "}\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
        "#include \"vpg_object_property_accessor.hpp\"\r\n"
        "\r\n"
        "#include <string>\r\n"
        "\r\n"
        "#include \"exception_macro.hpp\"\r\n"
        "#include \"i_object.hpp\"\r\n"
        "#include \"property_accessor_macro.hpp\"\r\n"
        "#include \"vcc_enum.hpp\"\r\n"
        "#include \"vpg_object_a.hpp\"\r\n"
        "#include \"vpg_object_a_property.hpp\"\r\n"
        "#include \"vpg_object_b.hpp\"\r\n"
        "#include \"vpg_object_b_property.hpp\"\r\n"
        "\r\n"
        "std::wstring VPGObjectAPropertyAccessor::_readString(const int64_t &objectProperty) const\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        auto obj = std::static_pointer_cast<VPGObjectA>(_Object);\r\n"
        "        assert(obj != nullptr);\r\n"
        "        switch(static_cast<VPGObjectAProperty>(objectProperty))\r\n"
        "        {\r\n"
        "        case VPGObjectAProperty::EnumA:\r\n"
        "            return obj->getEnumA();\r\n"
        "        default:\r\n"
        "            assert(false);\r\n"
        "        }\r\n"
        "    CATCH\r\n"
        "    return L\"\";\r\n"
        "}\r\n"
        "\r\n"
        "std::wstring VPGObjectAPropertyAccessor::_readStringAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "    CATCH\r\n"
        "    return L\"\";\r\n"
        "}\r\n"
        "\r\n"
        "std::wstring VPGObjectAPropertyAccessor::_readStringAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "    CATCH\r\n"
        "    return L\"\";\r\n"
        "}\r\n"
        "\r\n"
        "void VPGObjectAPropertyAccessor::_writeString(const int64_t &objectProperty, const std::wstring &value)\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        auto obj = std::static_pointer_cast<VPGObjectA>(_Object);\r\n"
        "        assert(obj != nullptr);\r\n"
        "        switch(static_cast<VPGObjectAProperty>(objectProperty))\r\n"
        "        {\r\n"
        "        case VPGObjectAProperty::EnumA:\r\n"
        "            obj->setEnumA(value);\r\n"
        "            break;\r\n"
        "        default:\r\n"
        "            assert(false);\r\n"
        "        }\r\n"
        "    CATCH\r\n"
        "}\r\n"
        "\r\n"
        "void VPGObjectAPropertyAccessor::_writeStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "    CATCH\r\n"
        "}\r\n"
        "\r\n"
        "void VPGObjectAPropertyAccessor::_writeStringAtKey(const int64_t &objectProperty, const std::wstring &/*value*/, const void */*key*/)\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "    CATCH\r\n"
        "}\r\n"
        "\r\n"
        "void VPGObjectAPropertyAccessor::_insertStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "    CATCH\r\n"
        "}\r\n"
        "\r\n"
        "std::wstring VPGObjectBPropertyAccessor::_readString(const int64_t &objectProperty) const\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        auto obj = std::static_pointer_cast<VPGObjectB>(_Object);\r\n"
        "        assert(obj != nullptr);\r\n"
        "        switch(static_cast<VPGObjectBProperty>(objectProperty))\r\n"
        "        {\r\n"
        "        case VPGObjectBProperty::EnumA:\r\n"
        "            return obj->getEnumA();\r\n"
        "        default:\r\n"
        "            assert(false);\r\n"
        "        }\r\n"
        "    CATCH\r\n"
        "    return L\"\";\r\n"
        "}\r\n"
        "\r\n"
        "std::wstring VPGObjectBPropertyAccessor::_readStringAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "    CATCH\r\n"
        "    return L\"\";\r\n"
        "}\r\n"
        "\r\n"
        "std::wstring VPGObjectBPropertyAccessor::_readStringAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "    CATCH\r\n"
        "    return L\"\";\r\n"
        "}\r\n"
        "\r\n"
        "void VPGObjectBPropertyAccessor::_writeString(const int64_t &objectProperty, const std::wstring &value)\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        auto obj = std::static_pointer_cast<VPGObjectB>(_Object);\r\n"
        "        assert(obj != nullptr);\r\n"
        "        switch(static_cast<VPGObjectBProperty>(objectProperty))\r\n"
        "        {\r\n"
        "        case VPGObjectBProperty::EnumA:\r\n"
        "            obj->setEnumA(value);\r\n"
        "            break;\r\n"
        "        default:\r\n"
        "            assert(false);\r\n"
        "        }\r\n"
        "    CATCH\r\n"
        "}\r\n"
        "\r\n"
        "void VPGObjectBPropertyAccessor::_writeStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "    CATCH\r\n"
        "}\r\n"
        "\r\n"
        "void VPGObjectBPropertyAccessor::_writeStringAtKey(const int64_t &objectProperty, const std::wstring &/*value*/, const void */*key*/)\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "    CATCH\r\n"
        "}\r\n"
        "\r\n"
        "void VPGObjectBPropertyAccessor::_insertStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
        "{\r\n"
        "    TRY\r\n"
        "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "    CATCH\r\n"
        "}\r\n"
        "\r\n"
        "namespace NamespaceA\r\n"
        "{\r\n"
        "    std::wstring VPGObjectNamespacePropertyAccessor::_readString(const int64_t &objectProperty) const\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            auto obj = std::static_pointer_cast<VPGObjectNamespace>(_Object);\r\n"
        "            assert(obj != nullptr);\r\n"
        "            switch(static_cast<VPGObjectNamespaceProperty>(objectProperty))\r\n"
        "            {\r\n"
        "            case VPGObjectNamespaceProperty::EnumA:\r\n"
        "                return obj->getEnumA();\r\n"
        "            default:\r\n"
        "                assert(false);\r\n"
        "            }\r\n"
        "        CATCH\r\n"
        "        return L\"\";\r\n"
        "    }\r\n"
        "\r\n"
        "    std::wstring VPGObjectNamespacePropertyAccessor::_readStringAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "        CATCH\r\n"
        "        return L\"\";\r\n"
        "    }\r\n"
        "\r\n"
        "    std::wstring VPGObjectNamespacePropertyAccessor::_readStringAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "        CATCH\r\n"
        "        return L\"\";\r\n"
        "    }\r\n"
        "\r\n"
        "    void VPGObjectNamespacePropertyAccessor::_writeString(const int64_t &objectProperty, const std::wstring &value)\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            auto obj = std::static_pointer_cast<VPGObjectNamespace>(_Object);\r\n"
        "            assert(obj != nullptr);\r\n"
        "            switch(static_cast<VPGObjectNamespaceProperty>(objectProperty))\r\n"
        "            {\r\n"
        "            case VPGObjectNamespaceProperty::EnumA:\r\n"
        "                obj->setEnumA(value);\r\n"
        "                break;\r\n"
        "            default:\r\n"
        "                assert(false);\r\n"
        "            }\r\n"
        "        CATCH\r\n"
        "    }\r\n"
        "\r\n"
        "    void VPGObjectNamespacePropertyAccessor::_writeStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "        CATCH\r\n"
        "    }\r\n"
        "\r\n"
        "    void VPGObjectNamespacePropertyAccessor::_writeStringAtKey(const int64_t &objectProperty, const std::wstring &/*value*/, const void */*key*/)\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "        CATCH\r\n"
        "    }\r\n"
        "\r\n"
        "    void VPGObjectNamespacePropertyAccessor::_insertStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "        CATCH\r\n"
        "    }\r\n"
        "\r\n"
        "    namespace NamespaceNested\r\n"
        "    {\r\n"
        "        std::wstring VPGObjectNamespaceNestedPropertyAccessor::_readString(const int64_t &objectProperty) const\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                auto obj = std::static_pointer_cast<VPGObjectNamespaceNested>(_Object);\r\n"
        "                assert(obj != nullptr);\r\n"
        "                switch(static_cast<VPGObjectNamespaceNestedProperty>(objectProperty))\r\n"
        "                {\r\n"
        "                case VPGObjectNamespaceNestedProperty::EnumA:\r\n"
        "                    return obj->getEnumA();\r\n"
        "                default:\r\n"
        "                    assert(false);\r\n"
        "                }\r\n"
        "            CATCH\r\n"
        "            return L\"\";\r\n"
        "        }\r\n"
        "\r\n"
        "        std::wstring VPGObjectNamespaceNestedPropertyAccessor::_readStringAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "            CATCH\r\n"
        "            return L\"\";\r\n"
        "        }\r\n"
        "\r\n"
        "        std::wstring VPGObjectNamespaceNestedPropertyAccessor::_readStringAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "            CATCH\r\n"
        "            return L\"\";\r\n"
        "        }\r\n"
        "\r\n"
        "        void VPGObjectNamespaceNestedPropertyAccessor::_writeString(const int64_t &objectProperty, const std::wstring &value)\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                auto obj = std::static_pointer_cast<VPGObjectNamespaceNested>(_Object);\r\n"
        "                assert(obj != nullptr);\r\n"
        "                switch(static_cast<VPGObjectNamespaceNestedProperty>(objectProperty))\r\n"
        "                {\r\n"
        "                case VPGObjectNamespaceNestedProperty::EnumA:\r\n"
        "                    obj->setEnumA(value);\r\n"
        "                    break;\r\n"
        "                default:\r\n"
        "                    assert(false);\r\n"
        "                }\r\n"
        "            CATCH\r\n"
        "        }\r\n"
        "\r\n"
        "        void VPGObjectNamespaceNestedPropertyAccessor::_writeStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "            CATCH\r\n"
        "        }\r\n"
        "\r\n"
        "        void VPGObjectNamespaceNestedPropertyAccessor::_writeStringAtKey(const int64_t &objectProperty, const std::wstring &/*value*/, const void */*key*/)\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "            CATCH\r\n"
        "        }\r\n"
        "\r\n"
        "        void VPGObjectNamespaceNestedPropertyAccessor::_insertStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "            CATCH\r\n"
        "        }\r\n"
        "    }\r\n"
        "}\r\n"
        "\r\n"
        "namespace NamespaceB\r\n"
        "{\r\n"
        "    std::wstring VPGObjectNamespacePropertyAccessor::_readString(const int64_t &objectProperty) const\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            auto obj = std::static_pointer_cast<VPGObjectNamespace>(_Object);\r\n"
        "            assert(obj != nullptr);\r\n"
        "            switch(static_cast<VPGObjectNamespaceProperty>(objectProperty))\r\n"
        "            {\r\n"
        "            case VPGObjectNamespaceProperty::EnumA:\r\n"
        "                return obj->getEnumA();\r\n"
        "            default:\r\n"
        "                assert(false);\r\n"
        "            }\r\n"
        "        CATCH\r\n"
        "        return L\"\";\r\n"
        "    }\r\n"
        "\r\n"
        "    std::wstring VPGObjectNamespacePropertyAccessor::_readStringAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "        CATCH\r\n"
        "        return L\"\";\r\n"
        "    }\r\n"
        "\r\n"
        "    std::wstring VPGObjectNamespacePropertyAccessor::_readStringAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "        CATCH\r\n"
        "        return L\"\";\r\n"
        "    }\r\n"
        "\r\n"
        "    void VPGObjectNamespacePropertyAccessor::_writeString(const int64_t &objectProperty, const std::wstring &value)\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            auto obj = std::static_pointer_cast<VPGObjectNamespace>(_Object);\r\n"
        "            assert(obj != nullptr);\r\n"
        "            switch(static_cast<VPGObjectNamespaceProperty>(objectProperty))\r\n"
        "            {\r\n"
        "            case VPGObjectNamespaceProperty::EnumA:\r\n"
        "                obj->setEnumA(value);\r\n"
        "                break;\r\n"
        "            default:\r\n"
        "                assert(false);\r\n"
        "            }\r\n"
        "        CATCH\r\n"
        "    }\r\n"
        "\r\n"
        "    void VPGObjectNamespacePropertyAccessor::_writeStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "        CATCH\r\n"
        "    }\r\n"
        "\r\n"
        "    void VPGObjectNamespacePropertyAccessor::_writeStringAtKey(const int64_t &objectProperty, const std::wstring &/*value*/, const void */*key*/)\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "        CATCH\r\n"
        "    }\r\n"
        "\r\n"
        "    void VPGObjectNamespacePropertyAccessor::_insertStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
        "    {\r\n"
        "        TRY\r\n"
        "            THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "        CATCH\r\n"
        "    }\r\n"
        "\r\n"
        "    namespace NamespaceNested\r\n"
        "    {\r\n"
        "        std::wstring VPGObjectNamespaceNestedPropertyAccessor::_readString(const int64_t &objectProperty) const\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                auto obj = std::static_pointer_cast<VPGObjectNamespaceNested>(_Object);\r\n"
        "                assert(obj != nullptr);\r\n"
        "                switch(static_cast<VPGObjectNamespaceNestedProperty>(objectProperty))\r\n"
        "                {\r\n"
        "                case VPGObjectNamespaceNestedProperty::EnumA:\r\n"
        "                    return obj->getEnumA();\r\n"
        "                default:\r\n"
        "                    assert(false);\r\n"
        "                }\r\n"
        "            CATCH\r\n"
        "            return L\"\";\r\n"
        "        }\r\n"
        "\r\n"
        "        std::wstring VPGObjectNamespaceNestedPropertyAccessor::_readStringAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "            CATCH\r\n"
        "            return L\"\";\r\n"
        "        }\r\n"
        "\r\n"
        "        std::wstring VPGObjectNamespaceNestedPropertyAccessor::_readStringAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "            CATCH\r\n"
        "            return L\"\";\r\n"
        "        }\r\n"
        "\r\n"
        "        void VPGObjectNamespaceNestedPropertyAccessor::_writeString(const int64_t &objectProperty, const std::wstring &value)\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                auto obj = std::static_pointer_cast<VPGObjectNamespaceNested>(_Object);\r\n"
        "                assert(obj != nullptr);\r\n"
        "                switch(static_cast<VPGObjectNamespaceNestedProperty>(objectProperty))\r\n"
        "                {\r\n"
        "                case VPGObjectNamespaceNestedProperty::EnumA:\r\n"
        "                    obj->setEnumA(value);\r\n"
        "                    break;\r\n"
        "                default:\r\n"
        "                    assert(false);\r\n"
        "                }\r\n"
        "            CATCH\r\n"
        "        }\r\n"
        "\r\n"
        "        void VPGObjectNamespaceNestedPropertyAccessor::_writeStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "            CATCH\r\n"
        "        }\r\n"
        "\r\n"
        "        void VPGObjectNamespaceNestedPropertyAccessor::_writeStringAtKey(const int64_t &objectProperty, const std::wstring &/*value*/, const void */*key*/)\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "            CATCH\r\n"
        "        }\r\n"
        "\r\n"
        "        void VPGObjectNamespaceNestedPropertyAccessor::_insertStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
        "        {\r\n"
        "            TRY\r\n"
        "                THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
        "            CATCH\r\n"
        "        }\r\n"
        "    }\r\n"
        "}\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, NoAccess)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    ReadWrite, // GETSET(bool, ReadWrite, false) @@NoAccess\r\n"
        "    Read, // GETSET(bool, Read, false) @@NoAccess\r\n"
        "    Write, // GETSET(bool, Write, false) @@NoAccess\r\n"
        "    NoAccess // GETSET(bool, NoAccess, false) @@NoAccess\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(enumClass, enumClassList);
    
    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->getLogConfig().get(), L"VPG", this->getFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->getLogConfig().get(), L"VPG", this->getProjectIncludeList(), this->getFilePathCpp(), enumClassList);
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathHpp()));
    EXPECT_FALSE(vcc::isFilePresent(this->getFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "{\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathHpp()), expectedHppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, AccessMode_Normal)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    ReadWrite, // GETSET(bool, ReadWrite, false) @@ReadWrite\r\n"
        "    Read, // GETSET(bool, Read, false) @@ReadOnly\r\n"
        "    Write, // GETSET(bool, Write, false) @@WriteOnly\r\n"
        "    NoAccess // GETSET(bool, NoAccess, false) @@NoAccess\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->getLogConfig().get(), L"VPG", this->getFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->getLogConfig().get(), L"VPG", this->getProjectIncludeList(), this->getFilePathCpp(), enumClassList);
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathHpp()));
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(bool, Bool)\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->getIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vpg_object.hpp\"\r\n"
    "#include \"vpg_object_property.hpp\"\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_readBool(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Read:\r\n"
    "            return obj->getRead();\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            return obj->getReadWrite();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_readBoolAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_readBoolAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeBool(const int64_t &objectProperty, const bool &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            obj->setReadWrite(value);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Write:\r\n"
    "            obj->setWrite(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeBoolAtKey(const int64_t &objectProperty, const bool &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, AccessMode_Vector)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    ReadWrite, // VECTOR(bool, ReadWrite) @@ReadWrite\r\n"
        "    Read, // VECTOR(bool, Read) @@ReadOnly\r\n"
        "    Write, // VECTOR(bool, Write) @@WriteOnly\r\n"
        "    NoAccess // VECTOR(bool, NoAccess) @@NoAccess\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(enumClass, enumClassList);
    
    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->getLogConfig().get(), L"VPG", this->getFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->getLogConfig().get(), L"VPG", this->getProjectIncludeList(), this->getFilePathCpp(), enumClassList);
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathHpp()));
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(bool, Bool)\r\n"
    "\r\n"
    "    PROPERTY_ACCESSOR_CONTAINER_HEADER\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->getIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include <vector>\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vpg_object.hpp\"\r\n"
    "#include \"vpg_object_property.hpp\"\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_readBool(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_readBoolAtIndex(const int64_t &objectProperty, const int64_t &index) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Read:\r\n"
    "            return obj->getReadAtIndex(index);\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            return obj->getReadWriteAtIndex(index);\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_readBoolAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeBool(const int64_t &objectProperty, const bool &/*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeBoolAtIndex(const int64_t &objectProperty, const bool &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            if (index > -1)\r\n"
    "                obj->setReadWriteAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->insertReadWrite(value);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Write:\r\n"
    "            if (index > -1)\r\n"
    "                obj->setWriteAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->insertWrite(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeBoolAtKey(const int64_t &objectProperty, const bool &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertBoolAtIndex(const int64_t &objectProperty, const bool &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            if (index > -1)\r\n"
    "                obj->insertReadWriteAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->insertReadWrite(value);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Write:\r\n"
    "            if (index > -1)\r\n"
    "                obj->insertWriteAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->insertWrite(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "size_t VPGObjectPropertyAccessor::_getCount(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            return obj->getReadWrite().size();\r\n"
    "        case VPGObjectProperty::Read:\r\n"
    "            return obj->getRead().size();\r\n"
    "        case VPGObjectProperty::Write:\r\n"
    "            return obj->getWrite().size();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "std::set<void *> VPGObjectPropertyAccessor::_getMapKeys(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    std::set<void *> result;\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return result;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_isContainKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_remove(const int64_t &objectProperty, const void *value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(value != nullptr);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite: {\r\n"
    "            auto valuePtr = static_cast<const bool *>(value);\r\n"
    "            assert(valuePtr != nullptr);\r\n"
    "            obj->removeReadWrite(*valuePtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::Write: {\r\n"
    "            auto valuePtr = static_cast<const bool *>(value);\r\n"
    "            assert(valuePtr != nullptr);\r\n"
    "            obj->removeWrite(*valuePtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_removeObject(const int64_t &objectProperty, const vcc::IObject */*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_removeAtIndex(const int64_t &objectProperty, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            obj->removeReadWriteAtIndex(index);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Write:\r\n"
    "            obj->removeWriteAtIndex(index);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_removeAtKey(const int64_t &objectProperty, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_clear(const int64_t &objectProperty)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            obj->clearReadWrite();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Write:\r\n"
    "            obj->clearWrite();\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, Multi)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectAProperty\r\n"
        "{\r\n"
        "    Bool // GETSET(bool, Bool, false)\r\n"
        "};\r\n"
        "\r\n"
        "enum class VPGObjectBProperty\r\n"
        "{\r\n"
        "    Bool // GETSET(bool, Bool, false)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->getLogConfig().get(), L"VPG", this->getFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->getLogConfig().get(), L"VPG", this->getProjectIncludeList(), this->getFilePathCpp(), enumClassList);
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathHpp()));
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "class VPGObjectAPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(bool, Bool)\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectAPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectAPropertyAccessor() {}\r\n"
    "};\r\n"
    "\r\n"
    "class VPGObjectBPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(bool, Bool)\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectBPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectBPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->getIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vpg_object_a.hpp\"\r\n"
    "#include \"vpg_object_a_property.hpp\"\r\n"
    "#include \"vpg_object_b.hpp\"\r\n"
    "#include \"vpg_object_b_property.hpp\"\r\n"
    "\r\n"
    "bool VPGObjectAPropertyAccessor::_readBool(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObjectA>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectAProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectAProperty::Bool:\r\n"
    "            return obj->getBool();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectAPropertyAccessor::_readBoolAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectAPropertyAccessor::_readBoolAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectAPropertyAccessor::_writeBool(const int64_t &objectProperty, const bool &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObjectA>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectAProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectAProperty::Bool:\r\n"
    "            obj->setBool(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectAPropertyAccessor::_writeBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectAPropertyAccessor::_writeBoolAtKey(const int64_t &objectProperty, const bool &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectAPropertyAccessor::_insertBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectBPropertyAccessor::_readBool(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObjectB>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectBProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectBProperty::Bool:\r\n"
    "            return obj->getBool();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectBPropertyAccessor::_readBoolAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectBPropertyAccessor::_readBoolAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectBPropertyAccessor::_writeBool(const int64_t &objectProperty, const bool &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObjectB>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectBProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectBProperty::Bool:\r\n"
    "            obj->setBool(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectBPropertyAccessor::_writeBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectBPropertyAccessor::_writeBoolAtKey(const int64_t &objectProperty, const bool &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectBPropertyAccessor::_insertBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, Object)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    Object // GETSET_SPTR_NULL(VPGObjectA, Object)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->getLogConfig().get(), L"VPG", this->getFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->getLogConfig().get(), L"VPG", this->getProjectIncludeList(), this->getFilePathCpp(), enumClassList);
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathHpp()));
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_OBJECT_HEADER(std::shared_ptr<vcc::IObject>, Object)\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->getIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include <memory>\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vpg_object.hpp\"\r\n"
    "#include \"vpg_object_a.hpp\"\r\n"
    "#include \"vpg_object_property.hpp\"\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_readObject(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Object:\r\n"
    "            return std::static_pointer_cast<vcc::IObject>(obj->getObject());\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_readObjectAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_readObjectAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeObject(const int64_t &objectProperty, std::shared_ptr<vcc::IObject> value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Object:\r\n"
    "            obj->setObject(std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeObjectAtIndex(const int64_t &objectProperty, std::shared_ptr<vcc::IObject> /*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeObjectAtKey(const int64_t &objectProperty, std::shared_ptr<vcc::IObject> /*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertObjectAtIndex(const int64_t &objectProperty, std::shared_ptr<vcc::IObject> /*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_cloneObject(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Object:\r\n"
    "            return std::static_pointer_cast<vcc::IObject>(obj->getObject()->clone());\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_cloneObjectAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_cloneObjectAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, Container)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    VectorInt, // VECTOR(int, VectorInt)\r\n"
        "    VectorEnum, // VECTOR(VCCEnum, VectorEnum)\r\n"
        "    VectorObj, // VECTOR_SPTR(VPGObjectA, VectorObj)\r\n"
        "    MapInt, // MAP(int, int, MapInt)\r\n"
        "    MapEnum, // MAP(char, VCCEnum, MapEnum)\r\n"
        "    MapObj, // MAP_SPTR_R(double, VPGObjectA, MapObj)\r\n"
        "    OrderedMapInt, // ORDERED_MAP(int, int, OrderedMapInt)\r\n"
        "    OrderedMapEnum, // ORDERED_MAP(char, VCCEnum, OrderedMapEnum)\r\n"
        "    OrderedMapObj // ORDERED_MAP_SPTR_R(double, VPGObjectA, OrderedMapObj)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(enumClass, enumClassList);
    
    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->getLogConfig().get(), L"VPG", this->getFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->getLogConfig().get(), L"VPG", this->getProjectIncludeList(), this->getFilePathCpp(), enumClassList);
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathHpp()));
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(int, Int)\r\n"
    "    PROPERTY_ACCESSOR_HEADER(long, Long)\r\n"
    "    PROPERTY_ACCESSOR_OBJECT_HEADER(std::shared_ptr<vcc::IObject>, Object)\r\n"
    "\r\n"
    "    PROPERTY_ACCESSOR_CONTAINER_HEADER\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->getIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include <map>\r\n"
    "#include <memory>\r\n"
    "#include <vector>\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vcc_enum.hpp\"\r\n"
    "#include \"vpg_object.hpp\"\r\n"
    "#include \"vpg_object_a.hpp\"\r\n"
    "#include \"vpg_object_property.hpp\"\r\n"
    "\r\n"
    "int VPGObjectPropertyAccessor::_readInt(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "int VPGObjectPropertyAccessor::_readIntAtIndex(const int64_t &objectProperty, const int64_t &index) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::OrderedMapInt:\r\n"
    "            return obj->getOrderedMapIntAtIndex(index).second;\r\n"
    "        case VPGObjectProperty::VectorInt:\r\n"
    "            return obj->getVectorIntAtIndex(index);\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "int VPGObjectPropertyAccessor::_readIntAtKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->getMapIntAtKey(*keyPtr);\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->getOrderedMapIntAtKey(*keyPtr);\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeInt(const int64_t &objectProperty, const int &/*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeIntAtIndex(const int64_t &objectProperty, const int &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorInt:\r\n"
    "            if (index > -1)\r\n"
    "                obj->setVectorIntAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->insertVectorInt(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeIntAtKey(const int64_t &objectProperty, const int &value, const void *key)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->isMapIntContainKey(*keyPtr))\r\n"
    "                obj->setMapIntAtKey(*keyPtr, value);\r\n"
    "            else\r\n"
    "                obj->insertMapIntAtKey(*keyPtr, value);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->isOrderedMapIntContainKey(*keyPtr))\r\n"
    "                obj->setOrderedMapIntAtKey(*keyPtr, value);\r\n"
    "            else\r\n"
    "                obj->insertOrderedMapIntAtKey(*keyPtr, value);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertIntAtIndex(const int64_t &objectProperty, const int &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorInt:\r\n"
    "            if (index > -1)\r\n"
    "                obj->insertVectorIntAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->insertVectorInt(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "long VPGObjectPropertyAccessor::_readLong(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return 0L;\r\n"
    "}\r\n"
    "\r\n"
    "long VPGObjectPropertyAccessor::_readLongAtIndex(const int64_t &objectProperty, const int64_t &index) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::OrderedMapEnum:\r\n"
    "            return static_cast<long>(obj->getOrderedMapEnumAtIndex(index).second);\r\n"
    "        case VPGObjectProperty::VectorEnum:\r\n"
    "            return static_cast<long>(obj->getVectorEnumAtIndex(index));\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0L;\r\n"
    "}\r\n"
    "\r\n"
    "long VPGObjectPropertyAccessor::_readLongAtKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return static_cast<long>(obj->getMapEnumAtKey(*keyPtr));\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return static_cast<long>(obj->getOrderedMapEnumAtKey(*keyPtr));\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0L;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeLong(const int64_t &objectProperty, const long &/*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeLongAtIndex(const int64_t &objectProperty, const long &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorEnum:\r\n"
    "            if (index > -1)\r\n"
    "                obj->setVectorEnumAtIndex(index, static_cast<VCCEnum>(value));\r\n"
    "            else\r\n"
    "                obj->insertVectorEnum(static_cast<VCCEnum>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeLongAtKey(const int64_t &objectProperty, const long &value, const void *key)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->isMapEnumContainKey(*keyPtr))\r\n"
    "                obj->setMapEnumAtKey(*keyPtr, static_cast<VCCEnum>(value));\r\n"
    "            else\r\n"
    "                obj->insertMapEnumAtKey(*keyPtr, static_cast<VCCEnum>(value));\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->isOrderedMapEnumContainKey(*keyPtr))\r\n"
    "                obj->setOrderedMapEnumAtKey(*keyPtr, static_cast<VCCEnum>(value));\r\n"
    "            else\r\n"
    "                obj->insertOrderedMapEnumAtKey(*keyPtr, static_cast<VCCEnum>(value));\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertLongAtIndex(const int64_t &objectProperty, const long &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorEnum:\r\n"
    "            if (index > -1)\r\n"
    "                obj->insertVectorEnumAtIndex(index, static_cast<VCCEnum>(value));\r\n"
    "            else\r\n"
    "                obj->insertVectorEnum(static_cast<VCCEnum>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_readObject(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_readObjectAtIndex(const int64_t &objectProperty, const int64_t &index) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::OrderedMapObj:\r\n"
    "            return std::static_pointer_cast<vcc::IObject>(obj->getOrderedMapObjAtIndex(index).second);\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            return std::static_pointer_cast<vcc::IObject>(obj->getVectorObjAtIndex(index));\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_readObjectAtKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return std::static_pointer_cast<vcc::IObject>(obj->getMapObjAtKey(*keyPtr));\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return std::static_pointer_cast<vcc::IObject>(obj->getOrderedMapObjAtKey(*keyPtr));\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeObject(const int64_t &objectProperty, std::shared_ptr<vcc::IObject> /*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeObjectAtIndex(const int64_t &objectProperty, std::shared_ptr<vcc::IObject> value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            if (index > -1)\r\n"
    "                obj->setVectorObjAtIndex(index, std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            else\r\n"
    "                obj->insertVectorObj(std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeObjectAtKey(const int64_t &objectProperty, std::shared_ptr<vcc::IObject> value, const void *key)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->isMapObjContainKey(*keyPtr))\r\n"
    "                obj->setMapObjAtKey(*keyPtr, std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            else\r\n"
    "                obj->insertMapObjAtKey(*keyPtr, std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->isOrderedMapObjContainKey(*keyPtr))\r\n"
    "                obj->setOrderedMapObjAtKey(*keyPtr, std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            else\r\n"
    "                obj->insertOrderedMapObjAtKey(*keyPtr, std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertObjectAtIndex(const int64_t &objectProperty, std::shared_ptr<vcc::IObject> value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            if (index > -1)\r\n"
    "                obj->insertVectorObjAtIndex(index, std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            else\r\n"
    "                obj->insertVectorObj(std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_cloneObject(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_cloneObjectAtIndex(const int64_t &objectProperty, const int64_t &index) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::OrderedMapObj:\r\n"
    "            return std::static_pointer_cast<vcc::IObject>(obj->cloneOrderedMapObjAtIndex(index));\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            return std::static_pointer_cast<vcc::IObject>(obj->cloneVectorObjAtIndex(index));\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_cloneObjectAtKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return std::static_pointer_cast<vcc::IObject>(obj->cloneMapObjAtKey(*keyPtr));\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return std::static_pointer_cast<vcc::IObject>(obj->cloneOrderedMapObjAtKey(*keyPtr));\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "size_t VPGObjectPropertyAccessor::_getCount(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorInt:\r\n"
    "            return obj->getVectorInt().size();\r\n"
    "        case VPGObjectProperty::VectorEnum:\r\n"
    "            return obj->getVectorEnum().size();\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            return obj->getVectorObj().size();\r\n"
    "        case VPGObjectProperty::MapInt:\r\n"
    "            return obj->getMapInt().size();\r\n"
    "        case VPGObjectProperty::MapEnum:\r\n"
    "            return obj->getMapEnum().size();\r\n"
    "        case VPGObjectProperty::MapObj:\r\n"
    "            return obj->getMapObj().size();\r\n"
    "        case VPGObjectProperty::OrderedMapInt:\r\n"
    "            return obj->getOrderedMapInt().size();\r\n"
    "        case VPGObjectProperty::OrderedMapEnum:\r\n"
    "            return obj->getOrderedMapEnum().size();\r\n"
    "        case VPGObjectProperty::OrderedMapObj:\r\n"
    "            return obj->getOrderedMapObj().size();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "std::set<void *> VPGObjectPropertyAccessor::_getMapKeys(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    std::set<void *> result;\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapEnum:\r\n"
    "            return obj->getMapEnumVoidKeys();\r\n"
    "        case VPGObjectProperty::MapInt:\r\n"
    "            return obj->getMapIntVoidKeys();\r\n"
    "        case VPGObjectProperty::MapObj:\r\n"
    "            return obj->getMapObjVoidKeys();\r\n"
    "        case VPGObjectProperty::OrderedMapEnum:\r\n"
    "            return obj->getOrderedMapEnumVoidKeys();\r\n"
    "        case VPGObjectProperty::OrderedMapInt:\r\n"
    "            return obj->getOrderedMapIntVoidKeys();\r\n"
    "        case VPGObjectProperty::OrderedMapObj:\r\n"
    "            return obj->getOrderedMapObjVoidKeys();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return result;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_isContainKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->isMapEnumContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::MapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->isMapIntContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::MapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->isMapObjContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->isOrderedMapEnumContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->isOrderedMapIntContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->isOrderedMapObjContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_remove(const int64_t &objectProperty, const void *value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(value != nullptr);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorEnum: {\r\n"
    "            auto valuePtr = static_cast<const VCCEnum *>(value);\r\n"
    "            assert(valuePtr != nullptr);\r\n"
    "            obj->removeVectorEnum(*valuePtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::VectorInt: {\r\n"
    "            auto valuePtr = static_cast<const int *>(value);\r\n"
    "            assert(valuePtr != nullptr);\r\n"
    "            obj->removeVectorInt(*valuePtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_removeObject(const int64_t &objectProperty, const vcc::IObject *value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(value != nullptr);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            obj->removeVectorObj(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_removeAtIndex(const int64_t &objectProperty, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::OrderedMapEnum:\r\n"
    "            obj->removeOrderedMapEnumAtIndex(index);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::OrderedMapInt:\r\n"
    "            obj->removeOrderedMapIntAtIndex(index);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::OrderedMapObj:\r\n"
    "            obj->removeOrderedMapObjAtIndex(index);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::VectorEnum:\r\n"
    "            obj->removeVectorEnumAtIndex(index);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::VectorInt:\r\n"
    "            obj->removeVectorIntAtIndex(index);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            obj->removeVectorObjAtIndex(index);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_removeAtKey(const int64_t &objectProperty, const void *key)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->removeMapEnumAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::MapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->removeMapIntAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::MapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->removeMapObjAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->removeOrderedMapEnumAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->removeOrderedMapIntAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->removeOrderedMapObjAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_clear(const int64_t &objectProperty)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorInt:\r\n"
    "            obj->clearVectorInt();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::VectorEnum:\r\n"
    "            obj->clearVectorEnum();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            obj->clearVectorObj();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::MapInt:\r\n"
    "            obj->clearMapInt();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::MapEnum:\r\n"
    "            obj->clearMapEnum();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::MapObj:\r\n"
    "            obj->clearMapObj();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::OrderedMapInt:\r\n"
    "            obj->clearOrderedMapInt();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::OrderedMapEnum:\r\n"
    "            obj->clearOrderedMapEnum();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::OrderedMapObj:\r\n"
    "            obj->clearOrderedMapObj();\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, Mix)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    Bool, // GETSET(bool, Bool, false)\r\n"
        "    String, // GETSET(std::wstring, String, L\"\")\r\n"
        "    Object, // GETSET_SPTR_NULL(VPGObjectA, Object)\r\n"
        "    Vector, // VECTOR(std::wstring, Vector)\r\n"
        "    Map // MAP(int, double, Map)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->getLogConfig().get(), L"VPG", this->getFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->getLogConfig().get(), L"VPG", this->getProjectIncludeList(), this->getFilePathCpp(), enumClassList);
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathHpp()));
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include <string>\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(bool, Bool)\r\n"
    "    PROPERTY_ACCESSOR_HEADER(double, Double)\r\n"
    "    PROPERTY_ACCESSOR_HEADER(std::wstring, String)\r\n"
    "    PROPERTY_ACCESSOR_OBJECT_HEADER(std::shared_ptr<vcc::IObject>, Object)\r\n"
    "\r\n"
    "    PROPERTY_ACCESSOR_CONTAINER_HEADER\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->getIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include <map>\r\n"
    "#include <memory>\r\n"
    "#include <string>\r\n"
    "#include <vector>\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vpg_object.hpp\"\r\n"
    "#include \"vpg_object_a.hpp\"\r\n"
    "#include \"vpg_object_property.hpp\"\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_readBool(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Bool:\r\n"
    "            return obj->getBool();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_readBoolAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_readBoolAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeBool(const int64_t &objectProperty, const bool &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Bool:\r\n"
    "            obj->setBool(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeBoolAtKey(const int64_t &objectProperty, const bool &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "double VPGObjectPropertyAccessor::_readDouble(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "double VPGObjectPropertyAccessor::_readDoubleAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "double VPGObjectPropertyAccessor::_readDoubleAtKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Map: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->getMapAtKey(*keyPtr);\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeDouble(const int64_t &objectProperty, const double &/*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeDoubleAtIndex(const int64_t &objectProperty, const double &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeDoubleAtKey(const int64_t &objectProperty, const double &value, const void *key)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Map: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->isMapContainKey(*keyPtr))\r\n"
    "                obj->setMapAtKey(*keyPtr, value);\r\n"
    "            else\r\n"
    "                obj->insertMapAtKey(*keyPtr, value);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertDoubleAtIndex(const int64_t &objectProperty, const double &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::wstring VPGObjectPropertyAccessor::_readString(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::String:\r\n"
    "            return obj->getString();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return L\"\";\r\n"
    "}\r\n"
    "\r\n"
    "std::wstring VPGObjectPropertyAccessor::_readStringAtIndex(const int64_t &objectProperty, const int64_t &index) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector:\r\n"
    "            return obj->getVectorAtIndex(index);\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return L\"\";\r\n"
    "}\r\n"
    "\r\n"
    "std::wstring VPGObjectPropertyAccessor::_readStringAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return L\"\";\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeString(const int64_t &objectProperty, const std::wstring &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::String:\r\n"
    "            obj->setString(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeStringAtIndex(const int64_t &objectProperty, const std::wstring &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector:\r\n"
    "            if (index > -1)\r\n"
    "                obj->setVectorAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->insertVector(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeStringAtKey(const int64_t &objectProperty, const std::wstring &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertStringAtIndex(const int64_t &objectProperty, const std::wstring &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector:\r\n"
    "            if (index > -1)\r\n"
    "                obj->insertVectorAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->insertVector(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_readObject(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Object:\r\n"
    "            return std::static_pointer_cast<vcc::IObject>(obj->getObject());\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_readObjectAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_readObjectAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeObject(const int64_t &objectProperty, std::shared_ptr<vcc::IObject> value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Object:\r\n"
    "            obj->setObject(std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeObjectAtIndex(const int64_t &objectProperty, std::shared_ptr<vcc::IObject> /*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_writeObjectAtKey(const int64_t &objectProperty, std::shared_ptr<vcc::IObject> /*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_insertObjectAtIndex(const int64_t &objectProperty, std::shared_ptr<vcc::IObject> /*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_cloneObject(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Object:\r\n"
    "            return std::static_pointer_cast<vcc::IObject>(obj->getObject()->clone());\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_cloneObjectAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<vcc::IObject> VPGObjectPropertyAccessor::_cloneObjectAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "size_t VPGObjectPropertyAccessor::_getCount(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector:\r\n"
    "            return obj->getVector().size();\r\n"
    "        case VPGObjectProperty::Map:\r\n"
    "            return obj->getMap().size();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "std::set<void *> VPGObjectPropertyAccessor::_getMapKeys(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    std::set<void *> result;\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Map:\r\n"
    "            return obj->getMapVoidKeys();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return result;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_isContainKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Map: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->isMapContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_remove(const int64_t &objectProperty, const void *value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(value != nullptr);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector: {\r\n"
    "            auto valuePtr = static_cast<const wchar_t *>(value);\r\n"
    "            assert(valuePtr != nullptr);\r\n"
    "            obj->removeVector(valuePtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_removeObject(const int64_t &objectProperty, const vcc::IObject */*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_removeAtIndex(const int64_t &objectProperty, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector:\r\n"
    "            obj->removeVectorAtIndex(index);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_removeAtKey(const int64_t &objectProperty, const void *key)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Map: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->removeMapAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_clear(const int64_t &objectProperty)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector:\r\n"
    "            obj->clearVector();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Map:\r\n"
    "            obj->clearMap();\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, ManagerAndAction)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    GitManager, // MANAGER_SPTR_NULL(VPGGitManger, GitManager)\r\n"
        "    ActionManager, // MANAGER_SPTR_PARENT(VPGActionManager, ActionManager)\r\n"
        "    Action // ACTION(std::wstring, Vector)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->getLogConfig().get(), L"VPG", this->getFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->getLogConfig().get(), L"VPG", this->getProjectIncludeList(), this->getFilePathCpp(), enumClassList);
    EXPECT_TRUE(vcc::isFilePresent(this->getFilePathHpp()));
    EXPECT_FALSE(vcc::isFilePresent(this->getFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public vcc::BasePropertyAccessor\r\n"
    "{\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<vcc::IObject> object) : vcc::BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(vcc::readFile(this->getFilePathHpp()), expectedHppContent);
}
