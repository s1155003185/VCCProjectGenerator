#include <gtest/gtest.h>

#include <filesystem>
#include <map>
#include <string>
#include <vector>

#include "class_macro.hpp"
#include "file_helper.hpp"

#include "vpg_enum_class.hpp"
#include "vpg_enum_class_reader.hpp"
#include "vpg_file_generation_manager.hpp"
#include "vpg_global.hpp"
#include "vpg_property_accessor_generation_service.hpp"

using namespace vcc;

// same as TEST_F(VPGVccGenerationManagerTest, XXX)
// need to change TEST_F(VPGVccGenerationManagerTest, XXX)
class VPGPropertyAccessorFileGenerationServiceTest : public testing::Test 
{
    GETSET_SPTR_NULL(LogConfig, LogConfig);
    GETSET(std::wstring, Workspace, L"bin/Debug/VPGPropertyAccessorFileGenerationServiceTest/");
    
    GETSET(std::wstring, FilePathHpp, L"");
    GETSET(std::wstring, FilePathCpp, L"");
    GETSET(std::wstring, IncludeFileName, L"");

    MAP(std::wstring, std::wstring, ProjectIncludeList);
    public:
        void SetUp() override
        {
            this->_LogConfig = std::make_shared<LogConfig>();
            this->_LogConfig->SetIsConsoleLog(false);
            std::filesystem::remove_all(PATH(this->GetWorkspace()));

            this->_FilePathHpp = ConcatPaths({this->GetWorkspace(), L"vpg_object_property_accessor.hpp"});
            this->_FilePathCpp = ConcatPaths({this->GetWorkspace(), L"vpg_object_property_accessor.cpp"});
            this->_IncludeFileName = L"vpg_object_property_accessor.hpp";

            this->InsertProjectIncludeListAtKey(L"VCCEnum", L"vcc_enum.hpp");
            this->InsertProjectIncludeListAtKey(L"VPGObject", L"vpg_object.hpp");
            this->InsertProjectIncludeListAtKey(L"VPGObjectProperty", L"vpg_object_property.hpp");
            this->InsertProjectIncludeListAtKey(L"VPGObjectA", L"vpg_object_a.hpp");
            this->InsertProjectIncludeListAtKey(L"VPGObjectAProperty", L"vpg_object_a_property.hpp");
            this->InsertProjectIncludeListAtKey(L"VPGObjectB", L"vpg_object_b.hpp");
            this->InsertProjectIncludeListAtKey(L"VPGObjectBProperty", L"vpg_object_b_property.hpp");
        }

        void TearDown() override
        {
            std::filesystem::remove_all(PATH(this->GetWorkspace()));
        }
};

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, Single)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    Bool, // GETSET(bool, Bool, false)\r\n"
        "    String, // GETSET(std::string, String, \"\")\r\n"
        "    Wstring, // GETSET(std::wstring, Wstring, L\"\")\r\n"
        "    Enum // GETSET(VCCEnum, Enum, VCCEnum::VCCEnumA)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::GetEnumClassReader()->Parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->GetLogConfig().get(), L"VPG", this->GetFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->GetLogConfig().get(), L"VPG", this->GetProjectIncludeList(), this->GetFilePathCpp(), enumClassList);
    EXPECT_TRUE(IsFilePresent(this->GetFilePathHpp()));
    EXPECT_TRUE(IsFilePresent(this->GetFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include <string>\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(bool, Bool)\r\n"
    "    PROPERTY_ACCESSOR_HEADER(long, Long)\r\n"
    "    PROPERTY_ACCESSOR_HEADER(std::wstring, String)\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<IObject> object) : BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->GetIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include <string>\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vcc_enum.hpp\"\r\n"
    "#include \"vpg_object.hpp\"\r\n"
    "#include \"vpg_object_property.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_ReadBool(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Bool:\r\n"
    "            return obj->GetBool();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_ReadBoolAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_ReadBoolAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteBool(const int64_t &objectProperty, const bool &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Bool:\r\n"
    "            obj->SetBool(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteBoolAtKey(const int64_t &objectProperty, const bool &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "long VPGObjectPropertyAccessor::_ReadLong(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Enum:\r\n"
    "            return static_cast<long>(obj->GetEnum());\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0L;\r\n"
    "}\r\n"
    "\r\n"
    "long VPGObjectPropertyAccessor::_ReadLongAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return 0L;\r\n"
    "}\r\n"
    "\r\n"
    "long VPGObjectPropertyAccessor::_ReadLongAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return 0L;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteLong(const int64_t &objectProperty, const long &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Enum:\r\n"
    "            obj->SetEnum(static_cast<VCCEnum>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteLongAtIndex(const int64_t &objectProperty, const long &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteLongAtKey(const int64_t &objectProperty, const long &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertLongAtIndex(const int64_t &objectProperty, const long &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::wstring VPGObjectPropertyAccessor::_ReadString(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::String:\r\n"
    "            return str2wstr(obj->GetString());\r\n"
    "        case VPGObjectProperty::Wstring:\r\n"
    "            return obj->GetWstring();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return L\"\";\r\n"
    "}\r\n"
    "\r\n"
    "std::wstring VPGObjectPropertyAccessor::_ReadStringAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return L\"\";\r\n"
    "}\r\n"
    "\r\n"
    "std::wstring VPGObjectPropertyAccessor::_ReadStringAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return L\"\";\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteString(const int64_t &objectProperty, const std::wstring &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::String:\r\n"
    "            obj->SetString(wstr2str(value));\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Wstring:\r\n"
    "            obj->SetWstring(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteStringAtKey(const int64_t &objectProperty, const std::wstring &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertStringAtIndex(const int64_t &objectProperty, const std::wstring &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, NoAccess)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    ReadWrite, // GETSET(bool, ReadWrite, false) @@NoAccess\r\n"
        "    Read, // GETSET(bool, Read, false) @@NoAccess\r\n"
        "    Write, // GETSET(bool, Write, false) @@NoAccess\r\n"
        "    NoAccess // GETSET(bool, NoAccess, false) @@NoAccess\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::GetEnumClassReader()->Parse(enumClass, enumClassList);
    
    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->GetLogConfig().get(), L"VPG", this->GetFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->GetLogConfig().get(), L"VPG", this->GetProjectIncludeList(), this->GetFilePathCpp(), enumClassList);
    EXPECT_TRUE(IsFilePresent(this->GetFilePathHpp()));
    EXPECT_FALSE(IsFilePresent(this->GetFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public BasePropertyAccessor\r\n"
    "{\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<IObject> object) : BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathHpp()), expectedHppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, AccessMode_Normal)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    ReadWrite, // GETSET(bool, ReadWrite, false) @@ReadWrite\r\n"
        "    Read, // GETSET(bool, Read, false) @@ReadOnly\r\n"
        "    Write, // GETSET(bool, Write, false) @@WriteOnly\r\n"
        "    NoAccess // GETSET(bool, NoAccess, false) @@NoAccess\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::GetEnumClassReader()->Parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->GetLogConfig().get(), L"VPG", this->GetFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->GetLogConfig().get(), L"VPG", this->GetProjectIncludeList(), this->GetFilePathCpp(), enumClassList);
    EXPECT_TRUE(IsFilePresent(this->GetFilePathHpp()));
    EXPECT_TRUE(IsFilePresent(this->GetFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(bool, Bool)\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<IObject> object) : BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->GetIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vpg_object.hpp\"\r\n"
    "#include \"vpg_object_property.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_ReadBool(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Read:\r\n"
    "            return obj->GetRead();\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            return obj->GetReadWrite();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_ReadBoolAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_ReadBoolAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteBool(const int64_t &objectProperty, const bool &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            obj->SetReadWrite(value);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Write:\r\n"
    "            obj->SetWrite(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteBoolAtKey(const int64_t &objectProperty, const bool &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, AccessMode_Vector)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    ReadWrite, // VECTOR(bool, ReadWrite) @@ReadWrite\r\n"
        "    Read, // VECTOR(bool, Read) @@ReadOnly\r\n"
        "    Write, // VECTOR(bool, Write) @@WriteOnly\r\n"
        "    NoAccess // VECTOR(bool, NoAccess) @@NoAccess\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::GetEnumClassReader()->Parse(enumClass, enumClassList);
    
    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->GetLogConfig().get(), L"VPG", this->GetFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->GetLogConfig().get(), L"VPG", this->GetProjectIncludeList(), this->GetFilePathCpp(), enumClassList);
    EXPECT_TRUE(IsFilePresent(this->GetFilePathHpp()));
    EXPECT_TRUE(IsFilePresent(this->GetFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(bool, Bool)\r\n"
    "\r\n"
    "    PROPERTY_ACCESSOR_CONTAINER_HEADER\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<IObject> object) : BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->GetIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include <vector>\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vpg_object.hpp\"\r\n"
    "#include \"vpg_object_property.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_ReadBool(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_ReadBoolAtIndex(const int64_t &objectProperty, const int64_t &index) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Read:\r\n"
    "            return obj->GetReadAtIndex(index);\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            return obj->GetReadWriteAtIndex(index);\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_ReadBoolAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteBool(const int64_t &objectProperty, const bool &/*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteBoolAtIndex(const int64_t &objectProperty, const bool &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            if (index > -1)\r\n"
    "                obj->SetReadWriteAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->InsertReadWrite(value);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Write:\r\n"
    "            if (index > -1)\r\n"
    "                obj->SetWriteAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->InsertWrite(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteBoolAtKey(const int64_t &objectProperty, const bool &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertBoolAtIndex(const int64_t &objectProperty, const bool &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            if (index > -1)\r\n"
    "                obj->InsertReadWriteAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->InsertReadWrite(value);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Write:\r\n"
    "            if (index > -1)\r\n"
    "                obj->InsertWriteAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->InsertWrite(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "size_t VPGObjectPropertyAccessor::_GetCount(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            return obj->GetReadWrite().size();\r\n"
    "        case VPGObjectProperty::Read:\r\n"
    "            return obj->GetRead().size();\r\n"
    "        case VPGObjectProperty::Write:\r\n"
    "            return obj->GetWrite().size();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "std::set<void *> VPGObjectPropertyAccessor::_GetMapKeys(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    std::set<void *> result;\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return result;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_IsContainKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_Remove(const int64_t &objectProperty, const void *value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(value != nullptr);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite: {\r\n"
    "            auto valuePtr = static_cast<const bool *>(value);\r\n"
    "            assert(valuePtr != nullptr);\r\n"
    "            obj->RemoveReadWrite(*valuePtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::Write: {\r\n"
    "            auto valuePtr = static_cast<const bool *>(value);\r\n"
    "            assert(valuePtr != nullptr);\r\n"
    "            obj->RemoveWrite(*valuePtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_RemoveObject(const int64_t &objectProperty, const IObject */*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_RemoveAtIndex(const int64_t &objectProperty, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            obj->RemoveReadWriteAtIndex(index);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Write:\r\n"
    "            obj->RemoveWriteAtIndex(index);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_RemoveAtKey(const int64_t &objectProperty, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_Clear(const int64_t &objectProperty)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::ReadWrite:\r\n"
    "            obj->ClearReadWrite();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Write:\r\n"
    "            obj->ClearWrite();\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, Multi)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectAProperty\r\n"
        "{\r\n"
        "    Bool // GETSET(bool, Bool, false)\r\n"
        "};\r\n"
        "\r\n"
        "enum class VPGObjectBProperty\r\n"
        "{\r\n"
        "    Bool // GETSET(bool, Bool, false)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::GetEnumClassReader()->Parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->GetLogConfig().get(), L"VPG", this->GetFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->GetLogConfig().get(), L"VPG", this->GetProjectIncludeList(), this->GetFilePathCpp(), enumClassList);
    EXPECT_TRUE(IsFilePresent(this->GetFilePathHpp()));
    EXPECT_TRUE(IsFilePresent(this->GetFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "class VPGObjectAPropertyAccessor : public BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(bool, Bool)\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectAPropertyAccessor(std::shared_ptr<IObject> object) : BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectAPropertyAccessor() {}\r\n"
    "};\r\n"
    "\r\n"
    "class VPGObjectBPropertyAccessor : public BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(bool, Bool)\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectBPropertyAccessor(std::shared_ptr<IObject> object) : BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectBPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->GetIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vpg_object_a.hpp\"\r\n"
    "#include \"vpg_object_a_property.hpp\"\r\n"
    "#include \"vpg_object_b.hpp\"\r\n"
    "#include \"vpg_object_b_property.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "bool VPGObjectAPropertyAccessor::_ReadBool(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObjectA>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectAProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectAProperty::Bool:\r\n"
    "            return obj->GetBool();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectAPropertyAccessor::_ReadBoolAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectAPropertyAccessor::_ReadBoolAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectAPropertyAccessor::_WriteBool(const int64_t &objectProperty, const bool &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObjectA>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectAProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectAProperty::Bool:\r\n"
    "            obj->SetBool(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectAPropertyAccessor::_WriteBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectAPropertyAccessor::_WriteBoolAtKey(const int64_t &objectProperty, const bool &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectAPropertyAccessor::_InsertBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectBPropertyAccessor::_ReadBool(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObjectB>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectBProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectBProperty::Bool:\r\n"
    "            return obj->GetBool();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectBPropertyAccessor::_ReadBoolAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectBPropertyAccessor::_ReadBoolAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectBPropertyAccessor::_WriteBool(const int64_t &objectProperty, const bool &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObjectB>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectBProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectBProperty::Bool:\r\n"
    "            obj->SetBool(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectBPropertyAccessor::_WriteBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectBPropertyAccessor::_WriteBoolAtKey(const int64_t &objectProperty, const bool &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectBPropertyAccessor::_InsertBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, Object)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    Object // GETSET_SPTR_NULL(VPGObjectA, Object)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::GetEnumClassReader()->Parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->GetLogConfig().get(), L"VPG", this->GetFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->GetLogConfig().get(), L"VPG", this->GetProjectIncludeList(), this->GetFilePathCpp(), enumClassList);
    EXPECT_TRUE(IsFilePresent(this->GetFilePathHpp()));
    EXPECT_TRUE(IsFilePresent(this->GetFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_OBJECT_HEADER(std::shared_ptr<IObject>, Object)\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<IObject> object) : BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->GetIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include <memory>\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vpg_object.hpp\"\r\n"
    "#include \"vpg_object_a.hpp\"\r\n"
    "#include \"vpg_object_property.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_ReadObject(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Object:\r\n"
    "            return std::static_pointer_cast<IObject>(obj->GetObject());\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_ReadObjectAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_ReadObjectAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteObject(const int64_t &objectProperty, std::shared_ptr<IObject> value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Object:\r\n"
    "            obj->SetObject(std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteObjectAtIndex(const int64_t &objectProperty, std::shared_ptr<IObject> /*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteObjectAtKey(const int64_t &objectProperty, std::shared_ptr<IObject> /*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertObjectAtIndex(const int64_t &objectProperty, std::shared_ptr<IObject> /*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_CloneObject(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Object:\r\n"
    "            return std::static_pointer_cast<IObject>(obj->GetObject()->Clone());\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_CloneObjectAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_CloneObjectAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, Container)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    VectorInt, // VECTOR(int, VectorInt)\r\n"
        "    VectorEnum, // VECTOR(VCCEnum, VectorEnum)\r\n"
        "    VectorObj, // VECTOR_SPTR(VPGObjectA, VectorObj)\r\n"
        "    MapInt, // MAP(int, int, MapInt)\r\n"
        "    MapEnum, // MAP(char, VCCEnum, MapEnum)\r\n"
        "    MapObj, // MAP_SPTR_R(double, VPGObjectA, MapObj)\r\n"
        "    OrderedMapInt, // ORDERED_MAP(int, int, OrderedMapInt)\r\n"
        "    OrderedMapEnum, // ORDERED_MAP(char, VCCEnum, OrderedMapEnum)\r\n"
        "    OrderedMapObj // ORDERED_MAP_SPTR_R(double, VPGObjectA, OrderedMapObj)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::GetEnumClassReader()->Parse(enumClass, enumClassList);
    
    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->GetLogConfig().get(), L"VPG", this->GetFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->GetLogConfig().get(), L"VPG", this->GetProjectIncludeList(), this->GetFilePathCpp(), enumClassList);
    EXPECT_TRUE(IsFilePresent(this->GetFilePathHpp()));
    EXPECT_TRUE(IsFilePresent(this->GetFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(int, Int)\r\n"
    "    PROPERTY_ACCESSOR_HEADER(long, Long)\r\n"
    "    PROPERTY_ACCESSOR_OBJECT_HEADER(std::shared_ptr<IObject>, Object)\r\n"
    "\r\n"
    "    PROPERTY_ACCESSOR_CONTAINER_HEADER\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<IObject> object) : BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->GetIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include <map>\r\n"
    "#include <memory>\r\n"
    "#include <vector>\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vcc_enum.hpp\"\r\n"
    "#include \"vpg_object.hpp\"\r\n"
    "#include \"vpg_object_a.hpp\"\r\n"
    "#include \"vpg_object_property.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "int VPGObjectPropertyAccessor::_ReadInt(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "int VPGObjectPropertyAccessor::_ReadIntAtIndex(const int64_t &objectProperty, const int64_t &index) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::OrderedMapInt:\r\n"
    "            return obj->GetOrderedMapIntAtIndex(index).second;\r\n"
    "        case VPGObjectProperty::VectorInt:\r\n"
    "            return obj->GetVectorIntAtIndex(index);\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "int VPGObjectPropertyAccessor::_ReadIntAtKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->GetMapIntAtKey(*keyPtr);\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->GetOrderedMapIntAtKey(*keyPtr);\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteInt(const int64_t &objectProperty, const int &/*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteIntAtIndex(const int64_t &objectProperty, const int &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorInt:\r\n"
    "            if (index > -1)\r\n"
    "                obj->SetVectorIntAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->InsertVectorInt(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteIntAtKey(const int64_t &objectProperty, const int &value, const void *key)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->IsMapIntContainKey(*keyPtr))\r\n"
    "                obj->SetMapIntAtKey(*keyPtr, value);\r\n"
    "            else\r\n"
    "                obj->InsertMapIntAtKey(*keyPtr, value);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->IsOrderedMapIntContainKey(*keyPtr))\r\n"
    "                obj->SetOrderedMapIntAtKey(*keyPtr, value);\r\n"
    "            else\r\n"
    "                obj->InsertOrderedMapIntAtKey(*keyPtr, value);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertIntAtIndex(const int64_t &objectProperty, const int &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorInt:\r\n"
    "            if (index > -1)\r\n"
    "                obj->InsertVectorIntAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->InsertVectorInt(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "long VPGObjectPropertyAccessor::_ReadLong(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return 0L;\r\n"
    "}\r\n"
    "\r\n"
    "long VPGObjectPropertyAccessor::_ReadLongAtIndex(const int64_t &objectProperty, const int64_t &index) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::OrderedMapEnum:\r\n"
    "            return static_cast<long>(obj->GetOrderedMapEnumAtIndex(index).second);\r\n"
    "        case VPGObjectProperty::VectorEnum:\r\n"
    "            return static_cast<long>(obj->GetVectorEnumAtIndex(index));\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0L;\r\n"
    "}\r\n"
    "\r\n"
    "long VPGObjectPropertyAccessor::_ReadLongAtKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return static_cast<long>(obj->GetMapEnumAtKey(*keyPtr));\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return static_cast<long>(obj->GetOrderedMapEnumAtKey(*keyPtr));\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0L;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteLong(const int64_t &objectProperty, const long &/*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteLongAtIndex(const int64_t &objectProperty, const long &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorEnum:\r\n"
    "            if (index > -1)\r\n"
    "                obj->SetVectorEnumAtIndex(index, static_cast<VCCEnum>(value));\r\n"
    "            else\r\n"
    "                obj->InsertVectorEnum(static_cast<VCCEnum>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteLongAtKey(const int64_t &objectProperty, const long &value, const void *key)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->IsMapEnumContainKey(*keyPtr))\r\n"
    "                obj->SetMapEnumAtKey(*keyPtr, static_cast<VCCEnum>(value));\r\n"
    "            else\r\n"
    "                obj->InsertMapEnumAtKey(*keyPtr, static_cast<VCCEnum>(value));\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->IsOrderedMapEnumContainKey(*keyPtr))\r\n"
    "                obj->SetOrderedMapEnumAtKey(*keyPtr, static_cast<VCCEnum>(value));\r\n"
    "            else\r\n"
    "                obj->InsertOrderedMapEnumAtKey(*keyPtr, static_cast<VCCEnum>(value));\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertLongAtIndex(const int64_t &objectProperty, const long &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorEnum:\r\n"
    "            if (index > -1)\r\n"
    "                obj->InsertVectorEnumAtIndex(index, static_cast<VCCEnum>(value));\r\n"
    "            else\r\n"
    "                obj->InsertVectorEnum(static_cast<VCCEnum>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_ReadObject(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_ReadObjectAtIndex(const int64_t &objectProperty, const int64_t &index) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::OrderedMapObj:\r\n"
    "            return std::static_pointer_cast<IObject>(obj->GetOrderedMapObjAtIndex(index).second);\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            return std::static_pointer_cast<IObject>(obj->GetVectorObjAtIndex(index));\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_ReadObjectAtKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return std::static_pointer_cast<IObject>(obj->GetMapObjAtKey(*keyPtr));\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return std::static_pointer_cast<IObject>(obj->GetOrderedMapObjAtKey(*keyPtr));\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteObject(const int64_t &objectProperty, std::shared_ptr<IObject> /*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteObjectAtIndex(const int64_t &objectProperty, std::shared_ptr<IObject> value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            if (index > -1)\r\n"
    "                obj->SetVectorObjAtIndex(index, std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            else\r\n"
    "                obj->InsertVectorObj(std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteObjectAtKey(const int64_t &objectProperty, std::shared_ptr<IObject> value, const void *key)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->IsMapObjContainKey(*keyPtr))\r\n"
    "                obj->SetMapObjAtKey(*keyPtr, std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            else\r\n"
    "                obj->InsertMapObjAtKey(*keyPtr, std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->IsOrderedMapObjContainKey(*keyPtr))\r\n"
    "                obj->SetOrderedMapObjAtKey(*keyPtr, std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            else\r\n"
    "                obj->InsertOrderedMapObjAtKey(*keyPtr, std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertObjectAtIndex(const int64_t &objectProperty, std::shared_ptr<IObject> value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            if (index > -1)\r\n"
    "                obj->InsertVectorObjAtIndex(index, std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            else\r\n"
    "                obj->InsertVectorObj(std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_CloneObject(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_CloneObjectAtIndex(const int64_t &objectProperty, const int64_t &index) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::OrderedMapObj:\r\n"
    "            return std::static_pointer_cast<IObject>(obj->CloneOrderedMapObjAtIndex(index));\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            return std::static_pointer_cast<IObject>(obj->CloneVectorObjAtIndex(index));\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_CloneObjectAtKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return std::static_pointer_cast<IObject>(obj->CloneMapObjAtKey(*keyPtr));\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return std::static_pointer_cast<IObject>(obj->CloneOrderedMapObjAtKey(*keyPtr));\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "size_t VPGObjectPropertyAccessor::_GetCount(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorInt:\r\n"
    "            return obj->GetVectorInt().size();\r\n"
    "        case VPGObjectProperty::VectorEnum:\r\n"
    "            return obj->GetVectorEnum().size();\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            return obj->GetVectorObj().size();\r\n"
    "        case VPGObjectProperty::MapInt:\r\n"
    "            return obj->GetMapInt().size();\r\n"
    "        case VPGObjectProperty::MapEnum:\r\n"
    "            return obj->GetMapEnum().size();\r\n"
    "        case VPGObjectProperty::MapObj:\r\n"
    "            return obj->GetMapObj().size();\r\n"
    "        case VPGObjectProperty::OrderedMapInt:\r\n"
    "            return obj->GetOrderedMapInt().size();\r\n"
    "        case VPGObjectProperty::OrderedMapEnum:\r\n"
    "            return obj->GetOrderedMapEnum().size();\r\n"
    "        case VPGObjectProperty::OrderedMapObj:\r\n"
    "            return obj->GetOrderedMapObj().size();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "std::set<void *> VPGObjectPropertyAccessor::_GetMapKeys(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    std::set<void *> result;\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapEnum:\r\n"
    "            return obj->GetMapEnumVoidKeys();\r\n"
    "        case VPGObjectProperty::MapInt:\r\n"
    "            return obj->GetMapIntVoidKeys();\r\n"
    "        case VPGObjectProperty::MapObj:\r\n"
    "            return obj->GetMapObjVoidKeys();\r\n"
    "        case VPGObjectProperty::OrderedMapEnum:\r\n"
    "            return obj->GetOrderedMapEnumVoidKeys();\r\n"
    "        case VPGObjectProperty::OrderedMapInt:\r\n"
    "            return obj->GetOrderedMapIntVoidKeys();\r\n"
    "        case VPGObjectProperty::OrderedMapObj:\r\n"
    "            return obj->GetOrderedMapObjVoidKeys();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return result;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_IsContainKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->IsMapEnumContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::MapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->IsMapIntContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::MapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->IsMapObjContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->IsOrderedMapEnumContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->IsOrderedMapIntContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->IsOrderedMapObjContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_Remove(const int64_t &objectProperty, const void *value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(value != nullptr);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorEnum: {\r\n"
    "            auto valuePtr = static_cast<const VCCEnum *>(value);\r\n"
    "            assert(valuePtr != nullptr);\r\n"
    "            obj->RemoveVectorEnum(*valuePtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::VectorInt: {\r\n"
    "            auto valuePtr = static_cast<const int *>(value);\r\n"
    "            assert(valuePtr != nullptr);\r\n"
    "            obj->RemoveVectorInt(*valuePtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_RemoveObject(const int64_t &objectProperty, const IObject *value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(value != nullptr);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            obj->RemoveVectorObj(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_RemoveAtIndex(const int64_t &objectProperty, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::OrderedMapEnum:\r\n"
    "            obj->RemoveOrderedMapEnumAtIndex(index);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::OrderedMapInt:\r\n"
    "            obj->RemoveOrderedMapIntAtIndex(index);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::OrderedMapObj:\r\n"
    "            obj->RemoveOrderedMapObjAtIndex(index);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::VectorEnum:\r\n"
    "            obj->RemoveVectorEnumAtIndex(index);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::VectorInt:\r\n"
    "            obj->RemoveVectorIntAtIndex(index);\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            obj->RemoveVectorObjAtIndex(index);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_RemoveAtKey(const int64_t &objectProperty, const void *key)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::MapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->RemoveMapEnumAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::MapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->RemoveMapIntAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::MapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->RemoveMapObjAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapEnum: {\r\n"
    "            auto keyPtr = static_cast<const char *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->RemoveOrderedMapEnumAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapInt: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->RemoveOrderedMapIntAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        case VPGObjectProperty::OrderedMapObj: {\r\n"
    "            auto keyPtr = static_cast<const double *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->RemoveOrderedMapObjAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_Clear(const int64_t &objectProperty)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::VectorInt:\r\n"
    "            obj->ClearVectorInt();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::VectorEnum:\r\n"
    "            obj->ClearVectorEnum();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::VectorObj:\r\n"
    "            obj->ClearVectorObj();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::MapInt:\r\n"
    "            obj->ClearMapInt();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::MapEnum:\r\n"
    "            obj->ClearMapEnum();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::MapObj:\r\n"
    "            obj->ClearMapObj();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::OrderedMapInt:\r\n"
    "            obj->ClearOrderedMapInt();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::OrderedMapEnum:\r\n"
    "            obj->ClearOrderedMapEnum();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::OrderedMapObj:\r\n"
    "            obj->ClearOrderedMapObj();\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, Mix)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    Bool, // GETSET(bool, Bool, false)\r\n"
        "    String, // GETSET(std::wstring, String, L\"\")\r\n"
        "    Object, // GETSET_SPTR_NULL(VPGObjectA, Object)\r\n"
        "    Vector, // VECTOR(std::wstring, Vector)\r\n"
        "    Map // MAP(int, double, Map)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::GetEnumClassReader()->Parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->GetLogConfig().get(), L"VPG", this->GetFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->GetLogConfig().get(), L"VPG", this->GetProjectIncludeList(), this->GetFilePathCpp(), enumClassList);
    EXPECT_TRUE(IsFilePresent(this->GetFilePathHpp()));
    EXPECT_TRUE(IsFilePresent(this->GetFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include <string>\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public BasePropertyAccessor\r\n"
    "{\r\n"
    "    PROPERTY_ACCESSOR_HEADER(bool, Bool)\r\n"
    "    PROPERTY_ACCESSOR_HEADER(double, Double)\r\n"
    "    PROPERTY_ACCESSOR_HEADER(std::wstring, String)\r\n"
    "    PROPERTY_ACCESSOR_OBJECT_HEADER(std::shared_ptr<IObject>, Object)\r\n"
    "\r\n"
    "    PROPERTY_ACCESSOR_CONTAINER_HEADER\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<IObject> object) : BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathHpp()), expectedHppContent);

    std::wstring expectedCppContent = L""
    "#include \"" + this->GetIncludeFileName() + L"\"\r\n"
    "\r\n"
    "#include <map>\r\n"
    "#include <memory>\r\n"
    "#include <string>\r\n"
    "#include <vector>\r\n"
    "\r\n"
    "#include \"exception_macro.hpp\"\r\n"
    "#include \"i_object.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "#include \"vpg_object.hpp\"\r\n"
    "#include \"vpg_object_a.hpp\"\r\n"
    "#include \"vpg_object_property.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_ReadBool(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Bool:\r\n"
    "            return obj->GetBool();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_ReadBoolAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_ReadBoolAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteBool(const int64_t &objectProperty, const bool &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Bool:\r\n"
    "            obj->SetBool(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteBoolAtKey(const int64_t &objectProperty, const bool &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertBoolAtIndex(const int64_t &objectProperty, const bool &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "double VPGObjectPropertyAccessor::_ReadDouble(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "double VPGObjectPropertyAccessor::_ReadDoubleAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "double VPGObjectPropertyAccessor::_ReadDoubleAtKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Map: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->GetMapAtKey(*keyPtr);\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteDouble(const int64_t &objectProperty, const double &/*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteDoubleAtIndex(const int64_t &objectProperty, const double &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteDoubleAtKey(const int64_t &objectProperty, const double &value, const void *key)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Map: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            if (obj->IsMapContainKey(*keyPtr))\r\n"
    "                obj->SetMapAtKey(*keyPtr, value);\r\n"
    "            else\r\n"
    "                obj->InsertMapAtKey(*keyPtr, value);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertDoubleAtIndex(const int64_t &objectProperty, const double &/*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::wstring VPGObjectPropertyAccessor::_ReadString(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::String:\r\n"
    "            return obj->GetString();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return L\"\";\r\n"
    "}\r\n"
    "\r\n"
    "std::wstring VPGObjectPropertyAccessor::_ReadStringAtIndex(const int64_t &objectProperty, const int64_t &index) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector:\r\n"
    "            return obj->GetVectorAtIndex(index);\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return L\"\";\r\n"
    "}\r\n"
    "\r\n"
    "std::wstring VPGObjectPropertyAccessor::_ReadStringAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return L\"\";\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteString(const int64_t &objectProperty, const std::wstring &value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::String:\r\n"
    "            obj->SetString(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteStringAtIndex(const int64_t &objectProperty, const std::wstring &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector:\r\n"
    "            if (index > -1)\r\n"
    "                obj->SetVectorAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->InsertVector(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteStringAtKey(const int64_t &objectProperty, const std::wstring &/*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertStringAtIndex(const int64_t &objectProperty, const std::wstring &value, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector:\r\n"
    "            if (index > -1)\r\n"
    "                obj->InsertVectorAtIndex(index, value);\r\n"
    "            else\r\n"
    "                obj->InsertVector(value);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_ReadObject(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Object:\r\n"
    "            return std::static_pointer_cast<IObject>(obj->GetObject());\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_ReadObjectAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_ReadObjectAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteObject(const int64_t &objectProperty, std::shared_ptr<IObject> value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Object:\r\n"
    "            obj->SetObject(std::static_pointer_cast<VPGObjectA>(value));\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteObjectAtIndex(const int64_t &objectProperty, std::shared_ptr<IObject> /*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_WriteObjectAtKey(const int64_t &objectProperty, std::shared_ptr<IObject> /*value*/, const void */*key*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_InsertObjectAtIndex(const int64_t &objectProperty, std::shared_ptr<IObject> /*value*/, const int64_t &/*index*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_CloneObject(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Object:\r\n"
    "            return std::static_pointer_cast<IObject>(obj->GetObject()->Clone());\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_CloneObjectAtIndex(const int64_t &objectProperty, const int64_t &/*index*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "std::shared_ptr<IObject> VPGObjectPropertyAccessor::_CloneObjectAtKey(const int64_t &objectProperty, const void */*key*/) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "    return nullptr;\r\n"
    "}\r\n"
    "\r\n"
    "size_t VPGObjectPropertyAccessor::_GetCount(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector:\r\n"
    "            return obj->GetVector().size();\r\n"
    "        case VPGObjectProperty::Map:\r\n"
    "            return obj->GetMap().size();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return 0;\r\n"
    "}\r\n"
    "\r\n"
    "std::set<void *> VPGObjectPropertyAccessor::_GetMapKeys(const int64_t &objectProperty) const\r\n"
    "{\r\n"
    "    std::set<void *> result;\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Map:\r\n"
    "            return obj->GetMapVoidKeys();\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return result;\r\n"
    "}\r\n"
    "\r\n"
    "bool VPGObjectPropertyAccessor::_IsContainKey(const int64_t &objectProperty, const void *key) const\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Map: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            return obj->IsMapContainKey(*keyPtr);\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "    return false;\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_Remove(const int64_t &objectProperty, const void *value)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(value != nullptr);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector: {\r\n"
    "            auto valuePtr = static_cast<const wchar_t *>(value);\r\n"
    "            assert(valuePtr != nullptr);\r\n"
    "            obj->RemoveVector(valuePtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_RemoveObject(const int64_t &objectProperty, const IObject */*value*/)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        THROW_EXCEPTION_MSG_FOR_BASE_PROPERTY_ACCESSOR_DETAIL_PROPERTY_NOT_FOUND\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_RemoveAtIndex(const int64_t &objectProperty, const int64_t &index)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        assert(index >= -1);\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector:\r\n"
    "            obj->RemoveVectorAtIndex(index);\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_RemoveAtKey(const int64_t &objectProperty, const void *key)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        assert(key != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Map: {\r\n"
    "            auto keyPtr = static_cast<const int *>(key);\r\n"
    "            assert(keyPtr != nullptr);\r\n"
    "            if (keyPtr == nullptr)\r\n"
    "                THROW_EXCEPTION_MSG(ExceptionType::KeyInvalid, L\"Invalid Property Accessor Map Key\");\r\n"
    "            obj->RemoveMapAtKey(*keyPtr);\r\n"
    "            break;\r\n"
    "        }\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n"
    "\r\n"
    "void VPGObjectPropertyAccessor::_Clear(const int64_t &objectProperty)\r\n"
    "{\r\n"
    "    TRY\r\n"
    "        auto obj = std::static_pointer_cast<VPGObject>(_Object);\r\n"
    "        assert(obj != nullptr);\r\n"
    "        switch(static_cast<VPGObjectProperty>(objectProperty))\r\n"
    "        {\r\n"
    "        case VPGObjectProperty::Vector:\r\n"
    "            obj->ClearVector();\r\n"
    "            break;\r\n"
    "        case VPGObjectProperty::Map:\r\n"
    "            obj->ClearMap();\r\n"
    "            break;\r\n"
    "        default:\r\n"
    "            assert(false);\r\n"
    "        }\r\n"
    "    CATCH\r\n"
    "}\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathCpp()), expectedCppContent);
}

TEST_F(VPGPropertyAccessorFileGenerationServiceTest, ManagerAndAction)
{
    std::wstring enumClass = L"#pragma once\r\n"
        "\r\n"
        "enum class VPGObjectProperty\r\n"
        "{\r\n"
        "    GitManager, // MANAGER_SPTR_NULL(VPGGitManger, GitManager)\r\n"
        "    ActionManager, // MANAGER_SPTR_PARENT(VPGActionManager, ActionManager)\r\n"
        "    Action // ACTION(std::wstring, Vector)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::GetEnumClassReader()->Parse(enumClass, enumClassList);

    std::set<std::wstring> propertyTypes;
    VPGPropertyAccessorGenerationService::GenerateHpp(this->GetLogConfig().get(), L"VPG", this->GetFilePathHpp(), enumClassList);
    VPGPropertyAccessorGenerationService::GenerateCpp(this->GetLogConfig().get(), L"VPG", this->GetProjectIncludeList(), this->GetFilePathCpp(), enumClassList);
    EXPECT_TRUE(IsFilePresent(this->GetFilePathHpp()));
    EXPECT_FALSE(IsFilePresent(this->GetFilePathCpp()));

    std::wstring expectedHppContent = L""
    "#pragma once\r\n"
    "\r\n"
    "#include \"base_property_accessor.hpp\"\r\n"
    "#include \"property_accessor_macro.hpp\"\r\n"
    "\r\n"
    "using namespace vcc;\r\n"
    "\r\n"
    "class VPGObjectPropertyAccessor : public BasePropertyAccessor\r\n"
    "{\r\n"
    "\r\n"
    "    public:\r\n"
    "        VPGObjectPropertyAccessor(std::shared_ptr<IObject> object) : BasePropertyAccessor(object) {}\r\n"
    "        virtual ~VPGObjectPropertyAccessor() {}\r\n"
    "};\r\n";
    EXPECT_EQ(ReadFile(this->GetFilePathHpp()), expectedHppContent);
}
