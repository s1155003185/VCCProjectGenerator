#include <gtest/gtest.h>

#include <filesystem>
#include <string>

#include "class_macro.hpp"
#include "file_helper.hpp"

#include "vpg_file_generation_manager.hpp"
#include "vpg_global.hpp"
#include "vpg_java_generation_service.hpp"

class VPGJavaGenerationServiceTest : public testing::Test 
{
    GETSET_SPTR_NULL(vcc::LogConfig, LogConfig);
    GETSET(std::wstring, Workspace, L"bin/Debug/VPGJavaGenerationServiceTest/");
    GETSET_SPTR_NULL(VPGConfigExport, JavaOption);
    
    GETSET_SPTR_NULL(VPGConfig, Option);
    
    public:
        void SetUp() override
        {
            this->_LogConfig = std::make_shared<vcc::LogConfig>();
            this->_LogConfig->setIsConsoleLog(false);

            std::filesystem::remove_all(PATH(this->getWorkspace()));
            _Option = std::make_shared<VPGConfig>();
            _Option->setProjectPrefix(L"VPG");
            if (_Option->getInput() == nullptr)
                _Option->setInput(std::make_shared<VPGConfigInput>());
            _Option->getInput()->setTypeWorkspace(_Workspace);

            _JavaOption = std::make_shared<VPGConfigExport>();
            _Option->insertExports(_JavaOption);
            _JavaOption->setInterface(VPGConfigInterfaceType::Java);
            _JavaOption->setWorkspace(_Workspace);
            _JavaOption->setDllBridgeDirectory(L"src/main/java/com/vcc/test/");
            _JavaOption->setTypeDirectory(L"src/main/java/com/vcc/type");
            _JavaOption->setObjectDirectory(L"src/main/java/com/vcc/module");
            _JavaOption->setFormDirectory(L"src/main/java/com/vcc/form");
        }

        void TearDown() override
        {
            std::filesystem::remove_all(PATH(this->getWorkspace()));
        }
};

TEST_F(VPGJavaGenerationServiceTest, GenerateJavaBridge)
{
    vcc::writeFile(vcc::concatPaths({this->getWorkspace(), L"DllFunctions.h"}),
        L"// <vcc:vccproj gen=\"DEMAND\"/>\r\n"
        "#ifndef DLL_FUNCTIONS_H\r\n"
        "#define DLL_FUNCTIONS_H\r\n"
        "\r\n"
        "#include <string>\r\n"
        "\r\n"
        "#ifdef _WIN32\r\n"
        "#define DLLEXPORT __declspec (dllexport)\r\n"
        "#else\r\n"
        "#define DLLEXPORT extern\r\n"
        "#endif\r\n"
        "\r\n"
        "// <vcc:dllInterfaceHeader gen=\"REPLACE\">\r\n"
        "#include \"property_accessor_macro.hpp\"\r\n"
        "#include \"exception_macro.hpp\"\r\n"
        "\r\n"
        "// </vcc:dllInterfaceHeader>\r\n"
        "\r\n"
        "extern \"C\"\r\n"
        "{\r\n"
        "\r\n"
        "DLLEXPORT int getVersion(wchar_t **str);\r\n"
        "\r\n"
        "static std::shared_ptr<vcc::IObject> tmpObj;\r\n"
        "DLLEXPORT void *CreateObject(int64_t property)\r\n"
        "{\r\n"
        "    ObjectType objectType = static_cast<ObjectType>(property);\r\n"
        "    tmpObj = ObjectFactory::create(objectType);\r\n"
        "    return tmpObj.get();\r\n"
        "}\r\n"
        "\r\n"
        "// <vcc:dllInterface gen=\"REPLACE\">\r\n"
        "DLLEXPORT bool ReadBool(void *ref, int64_t property, int64_t index)\r\n"
        "{\r\n"
        "    TRY\r\n"
        "         IObject *object = static_cast<IObject *>(ref);\r\n"
        "         std::shared_ptr<vcc::IObject> ptr(object, [](IObject*){});\r\n"
        "         return PropertyAccessorFactory::create(ptr)->readBool(LockType::ReadLock, property, index);\r\n"
        "     CATCH \r\n"
        "     return false;\r\n"
        "} \r\n"
        "\r\n"
        "PROPERTY_ACCESSOR_DLL_EXPORT_MACRO_HEADER(char, Char)\r\n"
        "PROPERTY_ACCESSOR_DLL_EXPORT_MACRO_HEADER_STRING\r\n"
        "PROPERTY_ACCESSOR_DLL_EXPORT_MACRO_HEADER_OBJECT\r\n"
        "PROPERTY_ACCESSOR_DLL_EXPORT_MACRO_HEADER_CONTAINER\r\n"
        "// </vcc:dllInterface>\r\n"
        "\r\n"
        "}\r\n"
        "\r\n"
        "#endif\r\n", true);

    VPGJavaGenerationService::GenerateJavaBridge(this->getLogConfig().get(), L"", vcc::concatPaths({this->getWorkspace(), L"DllFunctions.h"}), this->getOption().get());
    EXPECT_TRUE(vcc::isFilePresent(vcc::concatPaths({this->getWorkspace(), this->getJavaOption()->getDllBridgeDirectory(), L"VPGDllFunctions.java"})));
    EXPECT_EQ(vcc::readFile(vcc::concatPaths({this->getWorkspace(), this->getJavaOption()->getDllBridgeDirectory(), L"VPGDllFunctions.java"})),
        L"package com.vcc.test;\r\n"
        "\r\n"
        "import com.sun.jna.Library;\r\n"
        "import com.sun.jna.Native;\r\n"
        "import com.sun.jna.Pointer;\r\n"
        "import com.sun.jna.ptr.PointerByReference;\r\n"
        "\r\n"
        "public interface VPGDllFunctions extends Library {\r\n"
        "    VPGDllFunctions Instance = loadLibrary();\r\n"
        "\r\n"
        "    static private VPGDllFunctions loadLibrary() {\r\n"
        "        String prefix = System.getProperty(\"os.name\").startsWith(\"Windows\") ? \"lib\" : \"\";\r\n"
        "        var lib = (VPGDllFunctions)Native.load(prefix + \"vpg\", VPGDllFunctions.class);\r\n"
        "        lib.applicationStart();\r\n"
        "        return lib;\r\n"
        "    }\r\n"
        "\r\n"
        "    int getVersion(PointerByReference str);\r\n"
        "    Pointer CreateObject(long property);\r\n"
        "    boolean ReadBool(Pointer ref, long property, long index);\r\n"
        "    byte readChar(Pointer ref, long property);\r\n"
        "    byte readCharAtIndex(Pointer ref, long property, long index);\r\n"
        "    byte readCharAtKey(Pointer ref, long property, Pointer key);\r\n"
        "    void writeChar(Pointer ref, long property, byte value);\r\n"
        "    void writeCharAtIndex(Pointer ref, long property, byte value, long index);\r\n"
        "    void writeCharAtKey(Pointer ref, long property, byte value, Pointer key);\r\n"
        "    void insertCharAtIndex(Pointer ref, long property, byte value, long index);\r\n"
        "    void readString(Pointer ref, long property, PointerByReference value);\r\n"
        "    void readStringAtIndex(Pointer ref, long property, PointerByReference value, long index);\r\n"
        "    void readStringAtKey(Pointer ref, long property, PointerByReference value, Pointer key);\r\n"
        "    void writeString(Pointer ref, long property, PointerByReference value);\r\n"
        "    void writeStringAtIndex(Pointer ref, long property, PointerByReference value, long index);\r\n"
        "    void writeStringAtKey(Pointer ref, long property, PointerByReference value, Pointer key);\r\n"
        "    void insertStringAtIndex(Pointer ref, long property, PointerByReference value, long index);\r\n"
        "    Pointer readObject(Pointer ref, long property);\r\n"
        "    Pointer readObjectAtIndex(Pointer ref, long property, long index);\r\n"
        "    Pointer readObjectAtKey(Pointer ref, long property, Pointer key);\r\n"
        "    void writeObject(Pointer ref, long property, Pointer value);\r\n"
        "    void writeObjectAtIndex(Pointer ref, long property, Pointer value, long index);\r\n"
        "    void writeObjectAtKey(Pointer ref, long property, Pointer value, Pointer key);\r\n"
        "    Pointer addObjectAtIndex(Pointer ref, long property, long objectType, long index);\r\n"
        "    void insertObjectAtIndex(Pointer ref, long property, Pointer value, long index);\r\n"
        "    long getCount(Pointer ref, long property);\r\n"
        "    Pointer getMapKeys(Pointer ref, long property);\r\n"
        "    boolean isContainKey(Pointer ref, long property, Pointer key);\r\n"
        "    void removeObject(Pointer ref, long property, Pointer value);\r\n"
        "    void removeAtIndex(Pointer ref, long property, long index);\r\n"
        "    void removeAtKey(Pointer ref, long property, Pointer key);\r\n"
        "    void clear(Pointer ref, long property);\r\n"
        "}\r\n"
        );
}

void validateGenerateEnum(const VPGJavaGenerationServiceTest *test, const std::wstring &enumClass1, const std::wstring &enumClass2)
{
    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList1;
    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList2;
    VPGGlobal::getEnumClassReader()->parse(enumClass1, enumClassList1);
    VPGGlobal::getEnumClassReader()->parse(enumClass2, enumClassList2);

    std::wstring filePath1 = vcc::concatPaths({test->getWorkspace(), test->getJavaOption()->getTypeDirectory(), L"VPGTypeA.java"});
    std::wstring filePath2 = vcc::concatPaths({test->getWorkspace(), test->getJavaOption()->getTypeDirectory(), L"VPGTypeBProperty.java"});
    
    VPGJavaGenerationService::GenerateEnum(test->getLogConfig().get(), filePath1, L"", enumClassList1.at(0).get(), test->getOption().get(), test->getJavaOption().get());
    VPGJavaGenerationService::GenerateEnum(test->getLogConfig().get(), filePath2, L"", enumClassList2.at(0).get(), test->getOption().get(), test->getJavaOption().get());
    
    EXPECT_TRUE(vcc::isFilePresent(filePath1));
    EXPECT_EQ(vcc::readFile(filePath1),
        L"package com.vcc.type;\r\n"
        "\r\n"
        "import java.util.Objects;\r\n"
        "\r\n"
        "public enum VPGTypeA {\r\n"
        "    EnumA(0),\r\n"
        "    EnumB(1),\r\n"
        "    EnumC(2);\r\n"
        "\r\n"
        "    public final Integer value;\r\n"
        "\r\n"
        "    VPGTypeA(Integer value) {\r\n"
        "        this.value = value;\r\n"
        "    }\r\n"
        "\r\n"
        "    public Integer getValue() {\r\n"
        "        return value;\r\n"
        "    }\r\n"
        "\r\n"
        "    public static VPGTypeA parse(Integer value) {\r\n"
        "        for (VPGTypeA type : values()) {\r\n"
        "            if (Objects.equals(type.value, value)) {\r\n"
        "                return type;\r\n"
        "            }\r\n"
        "        }\r\n"
        "        throw new IllegalArgumentException(\"Invalid VPGTypeA value: \" + value);\r\n"
        "    }\r\n"
        "\r\n"
        "}\r\n");

    EXPECT_TRUE(vcc::isFilePresent(filePath2));
    EXPECT_EQ(vcc::readFile(filePath2),
        L"package com.vcc.type;\r\n"
        "\r\n"
        "import java.util.Objects;\r\n"
        "\r\n"
        "public enum VPGTypeBProperty {\r\n"
        "    EnumA(0),\r\n"
        "    EnumB(1),\r\n"
        "    EnumC(999);\r\n"
        "\r\n"
        "    public final Integer value;\r\n"
        "\r\n"
        "    VPGTypeBProperty(Integer value) {\r\n"
        "        this.value = value;\r\n"
        "    }\r\n"
        "\r\n"
        "    public Integer getValue() {\r\n"
        "        return value;\r\n"
        "    }\r\n"
        "\r\n"
        "    public static VPGTypeBProperty parse(Integer value) {\r\n"
        "        for (VPGTypeBProperty type : values()) {\r\n"
        "            if (Objects.equals(type.value, value)) {\r\n"
        "                return type;\r\n"
        "            }\r\n"
        "        }\r\n"
        "        throw new IllegalArgumentException(\"Invalid VPGTypeBProperty value: \" + value);\r\n"
        "    }\r\n"
        "\r\n"
        "}\r\n");
}

TEST_F(VPGJavaGenerationServiceTest, GenerateEnum)
{
    std::wstring enumClass1 =
        L"#param once\r\n"
        "enum class VPGTypeA {\r\n"
        "   EnumA,\r\n"
        "   EnumB,\r\n"
        "   EnumC\r\n"
        "};\r\n";

    std::wstring enumClass2 =
        L"#param once\r\n"
        "enum class VPGTypeBProperty {\r\n"
        "   EnumA = 0, // GETSET(std::wstring, EnumA, L"")\r\n"
        "   EnumB, // GETSET(int64_t, EnumB, 1)\r\n"
        "   EnumC = 999 // VECTOR(double, EnumC)\r\n"
        "};\r\n";
    validateGenerateEnum(this, enumClass1, enumClass2);
}

TEST_F(VPGJavaGenerationServiceTest, GenerateEnum_Namespace)
{
    std::wstring enumClass1 =
        L"#param once\r\n"
        "namespace vcc\r\n"
        "{\r\n"
        "    enum class VPGTypeA {\r\n"
        "        EnumA,\r\n"
        "        EnumB,\r\n"
        "        EnumC\r\n"
        "    };\r\n"
        "};\r\n";

    std::wstring enumClass2 =
        L"#param once\r\n"
        "namespace vcc {\r\n"
        "    enum class VPGTypeBProperty {\r\n"
        "        EnumA = 0, // GETSET(std::wstring, EnumA, L"")\r\n"
        "        EnumB, // GETSET(int64_t, EnumB, 1)\r\n"
        "        EnumC = 999 // VECTOR(double, EnumC)\r\n"
        "    };\r\n"
        "};\r\n";
    validateGenerateEnum(this, enumClass1, enumClass2);
}

void validateGenerateObject(const VPGJavaGenerationServiceTest *test, const std::wstring &code)
{
    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(code, enumClassList);

    std::map<std::wstring, std::wstring> typeWorkspaceClassRelativePathMap;
    std::wstring filePath = vcc::concatPaths({test->getWorkspace(), test->getJavaOption()->getObjectDirectory(), L"VPGTypeB.java"});
    VPGJavaGenerationService::GenerateObject(test->getLogConfig().get(), filePath, L"", enumClassList.at(0).get(), typeWorkspaceClassRelativePathMap, typeWorkspaceClassRelativePathMap, test->getOption().get(), test->getJavaOption().get());
    
    EXPECT_TRUE(vcc::isFilePresent(filePath));
    EXPECT_EQ(vcc::readFile(filePath),
        L"package com.vcc.module;\r\n"
        "\r\n"
        "import com.sun.jna.Memory;\r\n"
        "import com.sun.jna.Native;\r\n"
        "import com.sun.jna.Pointer;\r\n"
        "import com.sun.jna.ptr.PointerByReference;\r\n"
        "import com.vcc.test.VPGDllFunctions;\r\n"
        "import com.vcc.type.VPGTypeBProperty;\r\n"
        "import java.util.HashSet;\r\n"
        "import java.util.Set;\r\n"
        "\r\n"
        "public class VPGTypeB {\r\n"
        "\r\n"
        "    public Pointer Handle = null;\r\n"
        "\r\n"
        "    public VPGTypeB(Pointer handle) {\r\n"
        "        this.Handle = handle;\r\n"
        "    }\r\n"
        "\r\n"
        "    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Properties\">\r\n"
        "    public boolean getBool() {\r\n"
        "        return VPGDllFunctions.Instance.readBool(Handle, VPGTypeBProperty.Bool.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setBool(boolean value) {\r\n"
        "        VPGDllFunctions.Instance.writeBool(Handle, VPGTypeBProperty.Bool.getValue(), value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getLong() {\r\n"
        "        return VPGDllFunctions.Instance.readLong(Handle, VPGTypeBProperty.Long.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setLong(long value) {\r\n"
        "        VPGDllFunctions.Instance.writeLong(Handle, VPGTypeBProperty.Long.getValue(), value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public float getFloat() {\r\n"
        "        return VPGDllFunctions.Instance.readFloat(Handle, VPGTypeBProperty.Float.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setFloat(float value) {\r\n"
        "        VPGDllFunctions.Instance.writeFloat(Handle, VPGTypeBProperty.Float.getValue(), value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public byte getChar() {\r\n"
        "        return VPGDllFunctions.Instance.readChar(Handle, VPGTypeBProperty.Char.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setChar(byte value) {\r\n"
        "        VPGDllFunctions.Instance.writeChar(Handle, VPGTypeBProperty.Char.getValue(), value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public char getWChar() {\r\n"
        "        return VPGDllFunctions.Instance.readWchar(Handle, VPGTypeBProperty.WChar.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setWChar(char value) {\r\n"
        "        VPGDllFunctions.Instance.writeWchar(Handle, VPGTypeBProperty.WChar.getValue(), value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public String getString() {\r\n"
        "        PointerByReference result = new PointerByReference();\r\n"
        "        VPGDllFunctions.Instance.readString(Handle, VPGTypeBProperty.String.getValue(), result);\r\n"
        "        return result.getValue().getWideString(0);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setString(String value) {\r\n"
        "        Pointer valuePtr = new Memory(Native.WCHAR_SIZE * (value.length() + 1));\r\n"
        "        valuePtr.setWideString(0, value);\r\n"
        "        PointerByReference valueReference = new PointerByReference();\r\n"
        "        valueReference.setValue(valuePtr);\r\n"
        "        VPGDllFunctions.Instance.writeString(Handle, VPGTypeBProperty.String.getValue(), valueReference);\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeBProperty getEnum() {\r\n"
        "        return VPGTypeBProperty.parse((int)VPGDllFunctions.Instance.readLong(Handle, VPGTypeBProperty.Enum.getValue()));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setEnum(VPGTypeBProperty value) {\r\n"
        "        VPGDllFunctions.Instance.writeLong(Handle, VPGTypeBProperty.Enum.getValue(), value.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeB getObject() {\r\n"
        "        return new VPGTypeB(VPGDllFunctions.Instance.readObject(Handle, VPGTypeBProperty.Object.getValue()));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setObject(VPGTypeB value) {\r\n"
        "        VPGDllFunctions.Instance.writeObject(Handle, VPGTypeBProperty.Object.getValue(), value.Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getVectorDoubleCount() {\r\n"
        "        return VPGDllFunctions.Instance.getCount(Handle, VPGTypeBProperty.VectorDouble.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public double getVectorDoubleAtIndex(long index) {\r\n"
        "        return VPGDllFunctions.Instance.readDoubleAtIndex(Handle, VPGTypeBProperty.VectorDouble.getValue(), index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setVectorDoubleAtIndex(long index, double value) {\r\n"
        "        VPGDllFunctions.Instance.writeDoubleAtIndex(Handle, VPGTypeBProperty.VectorDouble.getValue(), value, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertVectorDouble(double value) {\r\n"
        "        insertVectorDoubleAtIndex(-1, value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertVectorDoubleAtIndex(long index, double value) {\r\n"
        "        VPGDllFunctions.Instance.insertDoubleAtIndex(Handle, VPGTypeBProperty.VectorDouble.getValue(), value, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeVectorDoubleAtIndex(long index) {\r\n"
        "        VPGDllFunctions.Instance.removeAtIndex(Handle, VPGTypeBProperty.VectorDouble.getValue(), index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearVectorDouble() {\r\n"
        "        VPGDllFunctions.Instance.clear(Handle, VPGTypeBProperty.VectorDouble.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getVectorStringCount() {\r\n"
        "        return VPGDllFunctions.Instance.getCount(Handle, VPGTypeBProperty.VectorString.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public String getVectorStringAtIndex(long index) {\r\n"
        "        PointerByReference result = new PointerByReference();\r\n"
        "        VPGDllFunctions.Instance.readStringAtIndex(Handle, VPGTypeBProperty.VectorString.getValue(), result, index);\r\n"
        "        return result.getValue().getWideString(0);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setVectorStringAtIndex(long index, String value) {\r\n"
        "        Pointer valuePtr = new Memory(Native.WCHAR_SIZE * (value.length() + 1));\r\n"
        "        valuePtr.setWideString(0, value);\r\n"
        "        PointerByReference valueReference = new PointerByReference();\r\n"
        "        valueReference.setValue(valuePtr);\r\n"
        "        VPGDllFunctions.Instance.writeStringAtIndex(Handle, VPGTypeBProperty.VectorString.getValue(), valueReference, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertVectorString(String value) {\r\n"
        "        insertVectorStringAtIndex(-1, value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertVectorStringAtIndex(long index, String value) {\r\n"
        "        Pointer valuePtr = new Memory(Native.WCHAR_SIZE * (value.length() + 1));\r\n"
        "        valuePtr.setWideString(0, value);\r\n"
        "        PointerByReference valueReference = new PointerByReference();\r\n"
        "        valueReference.setValue(valuePtr);\r\n"
        "        VPGDllFunctions.Instance.insertStringAtIndex(Handle, VPGTypeBProperty.VectorString.getValue(), valueReference, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeVectorStringAtIndex(long index) {\r\n"
        "        VPGDllFunctions.Instance.removeAtIndex(Handle, VPGTypeBProperty.VectorString.getValue(), index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearVectorString() {\r\n"
        "        VPGDllFunctions.Instance.clear(Handle, VPGTypeBProperty.VectorString.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getMapCount() {\r\n"
        "        return VPGDllFunctions.Instance.getCount(Handle, VPGTypeBProperty.Map.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public double getMapAtKey(int key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(int.class));\r\n"
        "        keyPtr.setInt(0, key);\r\n"
        "        return VPGDllFunctions.Instance.readDoubleAtKey(Handle, VPGTypeBProperty.Map.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setMapAtKey(int key, double value) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(int.class));\r\n"
        "        keyPtr.setInt(0, key);\r\n"
        "        VPGDllFunctions.Instance.writeIntAtKey(Handle, VPGTypeBProperty.Map.getValue(), value, keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public Set<Integer> getMapKeys() {\r\n"
        "        Set<Integer> result = new HashSet<>();\r\n"
        "        Pointer ptrs = VPGDllFunctions.Instance.getMapKeys(Handle, VPGTypeBProperty.Map.getValue());\r\n"
        "        long total = getMapCount();\r\n"
        "        for (var ptr : ptrs.getPointerArray(0)) {\r\n"
        "            if (ptr == null) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "            result.add(ptr.getInteger(0));\r\n"
        "            if (result.size() >= total) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "        }\r\n"
        "        return result;\r\n"
        "    }\r\n"
        "\r\n"
        "    public boolean isMapContainKey(int key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(int.class));\r\n"
        "        keyPtr.setInt(0, key);\r\n"
        "        return VPGDllFunctions.Instance.isContainKey(Handle, VPGTypeBProperty.Map.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeMapAtKey(int key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(int.class));\r\n"
        "        keyPtr.setInt(0, key);\r\n"
        "        VPGDllFunctions.Instance.removeAtKey(Handle, VPGTypeBProperty.Map.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearMap() {\r\n"
        "        VPGDllFunctions.Instance.clear(Handle, VPGTypeBProperty.Map.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getOrderedMapCount() {\r\n"
        "        return VPGDllFunctions.Instance.getCount(Handle, VPGTypeBProperty.OrderedMap.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public double getOrderedMapAtKey(int key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(int.class));\r\n"
        "        keyPtr.setInt(0, key);\r\n"
        "        return VPGDllFunctions.Instance.readDoubleAtKey(Handle, VPGTypeBProperty.OrderedMap.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setOrderedMapAtKey(int key, double value) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(int.class));\r\n"
        "        keyPtr.setInt(0, key);\r\n"
        "        VPGDllFunctions.Instance.writeIntAtKey(Handle, VPGTypeBProperty.OrderedMap.getValue(), value, keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public Set<Integer> getOrderedMapKeys() {\r\n"
        "        Set<Integer> result = new HashSet<>();\r\n"
        "        Pointer ptrs = VPGDllFunctions.Instance.getMapKeys(Handle, VPGTypeBProperty.OrderedMap.getValue());\r\n"
        "        long total = getOrderedMapCount();\r\n"
        "        for (var ptr : ptrs.getPointerArray(0)) {\r\n"
        "            if (ptr == null) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "            result.add(ptr.getInteger(0));\r\n"
        "            if (result.size() >= total) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "        }\r\n"
        "        return result;\r\n"
        "    }\r\n"
        "\r\n"
        "    public boolean isOrderedMapContainKey(int key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(int.class));\r\n"
        "        keyPtr.setInt(0, key);\r\n"
        "        return VPGDllFunctions.Instance.isContainKey(Handle, VPGTypeBProperty.OrderedMap.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeOrderedMapAtKey(int key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(int.class));\r\n"
        "        keyPtr.setInt(0, key);\r\n"
        "        VPGDllFunctions.Instance.removeAtKey(Handle, VPGTypeBProperty.OrderedMap.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearOrderedMap() {\r\n"
        "        VPGDllFunctions.Instance.clear(Handle, VPGTypeBProperty.OrderedMap.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getVectorObjectCount() {\r\n"
        "        return VPGDllFunctions.Instance.getCount(Handle, VPGTypeBProperty.VectorObject.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeB getVectorObjectAtIndex(long index) {\r\n"
        "        return new VPGTypeB(VPGDllFunctions.Instance.readObjectAtIndex(Handle, VPGTypeBProperty.VectorObject.getValue(), index));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setVectorObjectAtIndex(long index, VPGTypeB value) {\r\n"
        "        VPGDllFunctions.Instance.writeObjectAtIndex(Handle, VPGTypeBProperty.VectorObject.getValue(), value.Handle, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeB addVectorObject() {\r\n"
        "        return addVectorObjectAtIndex(-1);\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeB addVectorObjectAtIndex(long index) {\r\n"
        "        return new VPGTypeB(VPGDllFunctions.Instance.addObjectAtIndex(Handle, VPGTypeBProperty.VectorObject.getValue(), VPGObjectType.TypeB.getValue(), index));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertVectorObject(VPGTypeB value) {\r\n"
        "        insertVectorObjectAtIndex(-1, value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertVectorObjectAtIndex(long index, VPGTypeB value) {\r\n"
        "        VPGDllFunctions.Instance.insertObjectAtIndex(Handle, VPGTypeBProperty.VectorObject.getValue(), value.Handle, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeVectorObject(VPGTypeB value) {\r\n"
        "        VPGDllFunctions.Instance.removeObject(Handle, VPGTypeBProperty.VectorObject.getValue(), value.Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeVectorObjectAtIndex(long index) {\r\n"
        "        VPGDllFunctions.Instance.removeAtIndex(Handle, VPGTypeBProperty.VectorObject.getValue(), index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearVectorObject() {\r\n"
        "        VPGDllFunctions.Instance.clear(Handle, VPGTypeBProperty.VectorObject.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getMapObjectCount() {\r\n"
        "        return VPGDllFunctions.Instance.getCount(Handle, VPGTypeBProperty.MapObject.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeB getMapObjectAtKey(String key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.WCHAR_SIZE * (key.length() + 1));\r\n"
        "        keyPtr.setWideString(0, key);\r\n"
        "        return new VPGTypeB(VPGDllFunctions.Instance.readObjectAtKey(Handle, VPGTypeBProperty.MapObject.getValue(), keyPtr));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setMapObjectAtKey(String key, VPGTypeB value) {\r\n"
        "        Pointer keyPtr = new Memory(Native.WCHAR_SIZE * (key.length() + 1));\r\n"
        "        keyPtr.setWideString(0, key);\r\n"
        "        VPGDllFunctions.Instance.writeObjectAtKey(Handle, VPGTypeBProperty.MapObject.getValue(), value.Handle, keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public Set<String> getMapObjectKeys() {\r\n"
        "        Set<String> result = new HashSet<>();\r\n"
        "        Pointer ptrs = VPGDllFunctions.Instance.getMapKeys(Handle, VPGTypeBProperty.MapObject.getValue());\r\n"
        "        long total = getMapObjectCount();\r\n"
        "        for (var ptr : ptrs.getPointerArray(0)) {\r\n"
        "            if (ptr == null) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "            result.add(ptr.getWideString(0));\r\n"
        "            if (result.size() >= total) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "        }\r\n"
        "        return result;\r\n"
        "    }\r\n"
        "\r\n"
        "    public boolean isMapObjectContainKey(String key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.WCHAR_SIZE * (key.length() + 1));\r\n"
        "        keyPtr.setWideString(0, key);\r\n"
        "        return VPGDllFunctions.Instance.isContainKey(Handle, VPGTypeBProperty.MapObject.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeMapObjectAtKey(String key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.WCHAR_SIZE * (key.length() + 1));\r\n"
        "        keyPtr.setWideString(0, key);\r\n"
        "        VPGDllFunctions.Instance.removeAtKey(Handle, VPGTypeBProperty.MapObject.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearMapObject() {\r\n"
        "        VPGDllFunctions.Instance.clear(Handle, VPGTypeBProperty.MapObject.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getOrderedMapObjectCount() {\r\n"
        "        return VPGDllFunctions.Instance.getCount(Handle, VPGTypeBProperty.OrderedMapObject.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeB getOrderedMapObjectAtKey(double key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(double.class));\r\n"
        "        keyPtr.setDouble(0, key);\r\n"
        "        return new VPGTypeB(VPGDllFunctions.Instance.readObjectAtKey(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), keyPtr));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setOrderedMapObjectAtKey(double key, VPGTypeB value) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(double.class));\r\n"
        "        keyPtr.setDouble(0, key);\r\n"
        "        VPGDllFunctions.Instance.writeObjectAtKey(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), value.Handle, keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public Set<Double> getOrderedMapObjectKeys() {\r\n"
        "        Set<Double> result = new HashSet<>();\r\n"
        "        Pointer ptrs = VPGDllFunctions.Instance.getMapKeys(Handle, VPGTypeBProperty.OrderedMapObject.getValue());\r\n"
        "        long total = getOrderedMapObjectCount();\r\n"
        "        for (var ptr : ptrs.getPointerArray(0)) {\r\n"
        "            if (ptr == null) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "            result.add(ptr.getDouble(0));\r\n"
        "            if (result.size() >= total) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "        }\r\n"
        "        return result;\r\n"
        "    }\r\n"
        "\r\n"
        "    public boolean isOrderedMapObjectContainKey(double key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(double.class));\r\n"
        "        keyPtr.setDouble(0, key);\r\n"
        "        return VPGDllFunctions.Instance.isContainKey(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeOrderedMapObjectAtKey(double key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(double.class));\r\n"
        "        keyPtr.setDouble(0, key);\r\n"
        "        VPGDllFunctions.Instance.removeAtKey(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearOrderedMapObject() {\r\n"
        "        VPGDllFunctions.Instance.clear(Handle, VPGTypeBProperty.OrderedMapObject.getValue());\r\n"
        "    }\r\n"
        "    // </editor-fold>\r\n"
        "}\r\n");
}

TEST_F(VPGJavaGenerationServiceTest, GenerateObject)
{
    validateGenerateObject(this, 
        L"#param once\r\n"
        "enum class VPGTypeBProperty {\r\n"
        "    Bool = 0, // GETSET(bool, Bool, false)\r\n"
        "    Long , // GETSET(long, Long, 0)\r\n"
        "    Float, // GETSET(float, Float, 0)\r\n"
        "    Char, // GETSET(char, Char, L'\\0')\r\n"
        "    WChar, // GETSET(wchar_t, WChar, L'\\0')\r\n"
        "    String, // GETSET(std::wstring, String, L\"\")\r\n"
        "    Enum, // GETSET(VPGTypeBProperty, Enum, VPGTypeBProperty::Bool)\r\n"
        "    Object = 50, // GETSET_SPTR_NULL(VPGTypeB, Object)\r\n"
        "    VectorDouble = 80, // VECTOR(double, VectorDouble)\r\n"
        "    VectorString, // VECTOR(std::wstring, VectorString)\r\n"
        "    Map, // MAP(int, double, Map)\r\n"
        "    OrderedMap, // ORDERED_MAP(int, double, OrderedMap)\r\n"
        "    VectorObject, // VECTOR_SPTR(VPGTypeB, VectorObject)\r\n"
        "    MapObject, // MAP_SPTR_R(std::wstring, VPGTypeB, MapObject)\r\n"
        "    OrderedMapObject // ORDERED_MAP_SPTR_R(double, VPGTypeB, OrderedMapObject)\r\n" 
        "};\r\n");
}

TEST_F(VPGJavaGenerationServiceTest, GenerateObjectWithNamespace)
{   
    validateGenerateObject(
        this,
        L"#param once\r\n"
        "namespace vcc {\r\n"
        "    enum class VPGTypeBProperty {\r\n"
        "        Bool = 0, // GETSET(bool, Bool, false)\r\n"
        "        Long , // GETSET(long, Long, 0)\r\n"
        "        Float, // GETSET(float, Float, 0)\r\n"
        "        Char, // GETSET(char, Char, L'\\0')\r\n"
        "        WChar, // GETSET(wchar_t, WChar, L'\\0')\r\n"
        "        String, // GETSET(std::wstring, String, L\"\")\r\n"
        "        Enum, // GETSET(vcc::VPGTypeBProperty, Enum, vcc::VPGTypeBProperty::Bool)\r\n"
        "        Object = 50, // GETSET_SPTR_NULL(vcc::VPGTypeB, Object)\r\n"
        "        VectorDouble = 80, // VECTOR(double, VectorDouble)\r\n"
        "        VectorString, // VECTOR(std::wstring, VectorString)\r\n"
        "        Map, // MAP(int, double, Map)\r\n"
        "        OrderedMap, // ORDERED_MAP(int, double, OrderedMap)\r\n"
        "        VectorObject, // VECTOR_SPTR(vcc::VPGTypeB, VectorObject)\r\n"
        "        MapObject, // MAP_SPTR_R(std::wstring, vcc::VPGTypeB, MapObject)\r\n"
        "        OrderedMapObject // ORDERED_MAP_SPTR_R(double, vcc::VPGTypeB, OrderedMapObject)\r\n" 
        "    };\r\n"
        "};\r\n");
}

TEST_F(VPGJavaGenerationServiceTest, GenerateForm)
{
    std::wstring enumClass =
        L"#param once\r\n"
        "// @@Form\r\n"
        "enum class VPGGitFormProperty {\r\n"
        "    Log // GETSET_SPTR_NULL(VPGGitLog, Log)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(enumClass, enumClassList);

    std::map<std::wstring, std::wstring> typeWorkspaceClassRelativePathMapObject, typeWorkspaceClassRelativePathMapForm;
    typeWorkspaceClassRelativePathMapObject.insert(std::make_pair(L"VPGGit", L"com.vcc.object"));
    std::wstring filePath = vcc::concatPaths({this->getWorkspace(), this->getJavaOption()->getObjectDirectory(), L"VPGGitLog.java"});
    VPGJavaGenerationService::GenerateObject(this->getLogConfig().get(), filePath, L"", enumClassList.at(0).get(), typeWorkspaceClassRelativePathMapObject, typeWorkspaceClassRelativePathMapForm, this->getOption().get(), this->getJavaOption().get());
    
    EXPECT_TRUE(vcc::isFilePresent(filePath));
    EXPECT_EQ(vcc::readFile(filePath),
        L"package com.vcc.form;\r\n"
        "\r\n"
        "import com.sun.jna.Pointer;\r\n"
        "import com.vcc.test.VPGDllFunctions;\r\n"
        //"import com.vcc.object.VPGGit;\r\n"
        "import com.vcc.type.VPGGitFormProperty;\r\n"
        "\r\n"
        "public class VPGGitForm {\r\n"
        "\r\n"
        "    public Pointer Handle = null;\r\n"
        "\r\n"
        "    public VPGGitForm(Pointer handle) {\r\n"
        "        this.Handle = handle;\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGGitForm() {\r\n"
        "        this.Handle = VPGDllFunctions.Instance.applicationCreateForm(VPGObjectType.GitForm.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Properties\">\r\n"
        "    public VPGGitLog getLog() {\r\n"
        "        return new VPGGitLog(VPGDllFunctions.Instance.readObject(Handle, VPGGitFormProperty.Log.getValue()));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setLog(VPGGitLog value) {\r\n"
        "        VPGDllFunctions.Instance.writeObject(Handle, VPGGitFormProperty.Log.getValue(), value.Handle);\r\n"
        "    }\r\n"
        "    // </editor-fold>\r\n"
        "\r\n"
        "    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Form Actions\">\r\n"
        "    public long clearAction() {\r\n"
        "        return VPGDllFunctions.Instance.applicationClearFormAction(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void close(boolean isForce) {\r\n"
        "        VPGDllFunctions.Instance.applicationCloseForm(Handle, isForce);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getActionCurrentSeqNo() {\r\n"
        "        return VPGDllFunctions.Instance.applicationGetFormActionCurrentSeqNo(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getActionFirstSeqNo() {\r\n"
        "        return VPGDllFunctions.Instance.applicationGetFormActionFirstSeqNo(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getActionLastSeqNo() {\r\n"
        "        return VPGDllFunctions.Instance.applicationGetFormActionLastSeqNo(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public boolean isClosable() {\r\n"
        "        return VPGDllFunctions.Instance.applicationIsFormClosable(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public boolean isClosed() {\r\n"
        "        return VPGDllFunctions.Instance.applicationIsFormClosed(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void redo(long noOfStep) {\r\n"
        "        VPGDllFunctions.Instance.applicationRedoFormAction(Handle, noOfStep);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void redoToSeqNo(long seqNo) {\r\n"
        "        VPGDllFunctions.Instance.applicationRedoFormActionToSeqNo(Handle, seqNo);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long truncateAction() {\r\n"
        "        return VPGDllFunctions.Instance.applicationTruncateFormAction(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void undo(long noOfStep) {\r\n"
        "        VPGDllFunctions.Instance.applicationUndoFormAction(Handle, noOfStep);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void undoToSeqNo(long seqNo) {\r\n"
        "        VPGDllFunctions.Instance.applicationUndoFormActionToSeqNo(Handle, seqNo);\r\n"
        "    }\r\n"
        "    // </editor-fold>\r\n"
        "}\r\n");
}

TEST_F(VPGJavaGenerationServiceTest, GenerateResult)
{
    std::wstring enumClass =
        L"#param once\r\n"
        "// @@Result\r\n"
        "enum class VPGGitResultProperty {\r\n"
        "    Log // GETSET_SPTR_NULL(VPGGitLog, Log)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::getEnumClassReader()->parse(enumClass, enumClassList);

    std::map<std::wstring, std::wstring> typeWorkspaceClassRelativePathMapObject, typeWorkspaceClassRelativePathMapForm;
    typeWorkspaceClassRelativePathMapObject.insert(std::make_pair(L"VPGGit", L"com.vcc.object"));
    std::wstring filePath = vcc::concatPaths({this->getWorkspace(), this->getJavaOption()->getObjectDirectory(), L"VPGGitLog.java"});
    VPGJavaGenerationService::GenerateObject(this->getLogConfig().get(), filePath, L"", enumClassList.at(0).get(), typeWorkspaceClassRelativePathMapObject, typeWorkspaceClassRelativePathMapForm, this->getOption().get(), this->getJavaOption().get());
    
    EXPECT_TRUE(vcc::isFilePresent(filePath));
    EXPECT_EQ(vcc::readFile(filePath),
        L"package com.vcc.module;\r\n"
        "\r\n"
        "import com.sun.jna.Pointer;\r\n"
        "import com.vcc.test.VPGDllFunctions;\r\n"
        "import com.vcc.type.VPGGitResultProperty;\r\n"
        "\r\n"
        "public class VPGGitResult extends VPGOperationResult {\r\n"
        "\r\n"
        "    public VPGGitResult(Pointer handle) {\r\n"
        "        super(handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Properties\">\r\n"
        "    public VPGGitLog getLog() {\r\n"
        "        return new VPGGitLog(VPGDllFunctions.Instance.readObject(Handle, VPGGitResultProperty.Log.getValue()));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setLog(VPGGitLog value) {\r\n"
        "        VPGDllFunctions.Instance.writeObject(Handle, VPGGitResultProperty.Log.getValue(), value.Handle);\r\n"
        "    }\r\n"
        "    // </editor-fold>\r\n"
        "}\r\n");
}
