#include <gtest/gtest.h>

#include <filesystem>
#include <string>

#include "class_macro.hpp"
#include "file_helper.hpp"

#include "vpg_file_generation_manager.hpp"
#include "vpg_global.hpp"
#include "vpg_java_generation_service.hpp"

using namespace vcc;

class VPGJavaGenerationServiceTest : public testing::Test 
{
    GETSET_SPTR(LogConfig, LogConfig);
    GETSET(std::wstring, Workspace, L"bin/Debug/VPGJavaGenerationServiceTest/");
    GETSET_SPTR_NULL(VPGGenerationOptionExport, JavaOption);
    
    GETSET_SPTR_NULL(VPGGenerationOption, Option);
    
    public:
        void SetUp() override
        {
            this->_LogConfig->SetIsConsoleLog(false);

            std::filesystem::remove_all(PATH(this->GetWorkspace()));

            _Option = std::make_shared<VPGGenerationOption>();
            _Option->SetProjectPrefix(L"VPG");
            _Option->SetTypeWorkspace(_Workspace);

            _JavaOption = std::make_shared<VPGGenerationOptionExport>();
            _Option->InsertExports(_JavaOption);
            _JavaOption->SetInterface(VPGGenerationOptionInterfaceType::Java);
            _JavaOption->SetWorkspace(_Workspace);
            _JavaOption->SetDllBridgeDirectory(L"src/main/java/com/vcc/test/");
            _JavaOption->SetTypeDirectory(L"src/main/java/com/vcc/type");
            _JavaOption->SetObjectDirectory(L"src/main/java/com/vcc/module");
            _JavaOption->SetFormDirectory(L"src/main/java/com/vcc/form");
        }

        void TearDown() override
        {
            std::filesystem::remove_all(PATH(this->GetWorkspace()));
        }
};

TEST_F(VPGJavaGenerationServiceTest, GenerateJavaBridge)
{
    WriteFile(ConcatPaths({this->GetWorkspace(), L"DllFunctions.h"}),
        L"// <vcc:vccproj gen=\"DEMAND\"/>\r\n"
        "#ifndef DLL_FUNCTIONS_H\r\n"
        "#define DLL_FUNCTIONS_H\r\n"
        "\r\n"
        "#include <string>\r\n"
        "\r\n"
        "#ifdef _WIN32\r\n"
        "#define DLLEXPORT __declspec (dllexport)\r\n"
        "#else\r\n"
        "#define DLLEXPORT extern\r\n"
        "#endif\r\n"
        "\r\n"
        "// <vcc:dllInterfaceHeader gen=\"REPLACE\">\r\n"
        "#include \"property_accessor_macro.hpp\"\r\n"
        "#include \"exception_macro.hpp\"\r\n"
        "\r\n"
        "using namespace vcc;\r\n"
        "// </vcc:dllInterfaceHeader>\r\n"
        "\r\n"
        "extern \"C\"\r\n"
        "{\r\n"
        "\r\n"
        "DLLEXPORT int GetVersion(wchar_t **str);\r\n"
        "\r\n"
        "static std::shared_ptr<IObject> tmpObj;\r\n"
        "DLLEXPORT void *CreateObject(int64_t property)\r\n"
        "{\r\n"
        "    ObjectType objectType = static_cast<ObjectType>(property);\r\n"
        "    tmpObj = ObjectFactory::Create(objectType);\r\n"
        "    return tmpObj.get();\r\n"
        "}\r\n"
        "\r\n"
        "// <vcc:dllInterface gen=\"REPLACE\">\r\n"
        "DLLEXPORT bool ReadBool(void *ref, int64_t property, int64_t index)\r\n"
        "{\r\n"
        "    TRY\r\n"
        "         IObject *object = static_cast<IObject *>(ref);\r\n"
        "         std::shared_ptr<IObject> ptr(object, [](IObject*){});\r\n"
        "         return PropertyAccessorFactory::Create(ptr)->ReadBool(LockType::ReadLock, property, index);\r\n"
        "     CATCH \r\n"
        "     return false;\r\n"
        "} \r\n"
        "\r\n"
        "PROPERTY_ACCESSOR_DLL_EXPORT_MACRO_HEADER(char, Char)\r\n"
        "PROPERTY_ACCESSOR_DLL_EXPORT_MACRO_HEADER_STRING\r\n"
        "PROPERTY_ACCESSOR_DLL_EXPORT_MACRO_HEADER_OBJECT\r\n"
        "PROPERTY_ACCESSOR_DLL_EXPORT_MACRO_HEADER_CONTAINER\r\n"
        "// </vcc:dllInterface>\r\n"
        "\r\n"
        "}\r\n"
        "\r\n"
        "#endif\r\n", true);

    VPGJavaGenerationService::GenerateJavaBridge(this->GetLogConfig().get(), L"", ConcatPaths({this->GetWorkspace(), L"DllFunctions.h"}), this->GetOption().get());
    EXPECT_TRUE(IsFileExists(ConcatPaths({this->GetWorkspace(), this->GetJavaOption()->GetDllBridgeDirectory(), L"VPGDllFunctions.java"})));
    EXPECT_EQ(ReadFile(ConcatPaths({this->GetWorkspace(), this->GetJavaOption()->GetDllBridgeDirectory(), L"VPGDllFunctions.java"})),
        L"package com.vcc.test;\r\n"
        "\r\n"
        "import com.sun.jna.Library;\r\n"
        "import com.sun.jna.Native;\r\n"
        "import com.sun.jna.Pointer;\r\n"
        "import com.sun.jna.ptr.PointerByReference;\r\n"
        "\r\n"
        "public interface VPGDllFunctions extends Library {\r\n"
        "    VPGDllFunctions Instance = loadLibrary();\r\n"
        "\r\n"
        "    static private VPGDllFunctions loadLibrary() {\r\n"
        "        String prefix = System.getProperty(\"os.name\").startsWith(\"Windows\") ? \"lib\" : \"\";\r\n"
        "        var lib = (VPGDllFunctions)Native.load(prefix + \"vpg\", VPGDllFunctions.class);\r\n"
        "        lib.ApplicationStart();\r\n"
        "        return lib;\r\n"
        "    }\r\n"
        "\r\n"
        "    int GetVersion(PointerByReference str);\r\n"
        "    Pointer CreateObject(long property);\r\n"
        "    boolean ReadBool(Pointer ref, long property, long index);\r\n"
        "    byte ReadChar(Pointer ref, long property);\r\n"
        "    byte ReadCharAtIndex(Pointer ref, long property, long index);\r\n"
        "    byte ReadCharAtKey(Pointer ref, long property, Pointer key);\r\n"
        "    void WriteChar(Pointer ref, long property, byte value);\r\n"
        "    void WriteCharAtIndex(Pointer ref, long property, byte value, long index);\r\n"
        "    void WriteCharAtKey(Pointer ref, long property, byte value, Pointer key);\r\n"
        "    void InsertCharAtIndex(Pointer ref, long property, byte value, long index);\r\n"
        "    void ReadString(Pointer ref, long property, PointerByReference value);\r\n"
        "    void ReadStringAtIndex(Pointer ref, long property, PointerByReference value, long index);\r\n"
        "    void ReadStringAtKey(Pointer ref, long property, PointerByReference value, Pointer key);\r\n"
        "    void WriteString(Pointer ref, long property, PointerByReference value);\r\n"
        "    void WriteStringAtIndex(Pointer ref, long property, PointerByReference value, long index);\r\n"
        "    void WriteStringAtKey(Pointer ref, long property, PointerByReference value, Pointer key);\r\n"
        "    void InsertStringAtIndex(Pointer ref, long property, PointerByReference value, long index);\r\n"
        "    Pointer ReadObject(Pointer ref, long property);\r\n"
        "    Pointer ReadObjectAtIndex(Pointer ref, long property, long index);\r\n"
        "    Pointer ReadObjectAtKey(Pointer ref, long property, Pointer key);\r\n"
        "    void WriteObject(Pointer ref, long property, Pointer value);\r\n"
        "    void WriteObjectAtIndex(Pointer ref, long property, Pointer value, long index);\r\n"
        "    void WriteObjectAtKey(Pointer ref, long property, Pointer value, Pointer key);\r\n"
        "    Pointer AddObjectAtIndex(Pointer ref, long property, long objectType, long index);\r\n"
        "    void InsertObjectAtIndex(Pointer ref, long property, Pointer value, long index);\r\n"
        "    long GetCount(Pointer ref, long property);\r\n"
        "    Pointer GetMapKeys(Pointer ref, long property);\r\n"
        "    boolean IsContainKey(Pointer ref, long property, Pointer key);\r\n"
        "    void RemoveObject(Pointer ref, long property, Pointer value);\r\n"
        "    void RemoveAtIndex(Pointer ref, long property, long index);\r\n"
        "    void RemoveAtKey(Pointer ref, long property, Pointer key);\r\n"
        "    void Clear(Pointer ref, long property);\r\n"
        "}\r\n"
        );
}

TEST_F(VPGJavaGenerationServiceTest, GenerateEnum)
{
    std::wstring enumClass1 =
        L"#param once\r\n"
        "enum class VPGTypeA {\r\n"
        "   EnumA,\r\n"
        "   EnumB,\r\n"
        "   EnumC\r\n"
        "};\r\n";

    std::wstring enumClass2 =
        L"#param once\r\n"
        "enum class VPGTypeBProperty {\r\n"
        "   EnumA = 0, // GETSET(std::wstring, EnumA, L"")\r\n"
        "   EnumB, // GETSET(int64_t, EnumB, 1)\r\n"
        "   EnumC = 999 // VECTOR(double, EnumC)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList1;
    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList2;
    VPGGlobal::GetEnumClassReader()->Parse(enumClass1, enumClassList1);
    VPGGlobal::GetEnumClassReader()->Parse(enumClass2, enumClassList2);

    std::wstring filePath1 = ConcatPaths({this->GetWorkspace(), this->GetJavaOption()->GetTypeDirectory(), L"VPGTypeA.java"});
    std::wstring filePath2 = ConcatPaths({this->GetWorkspace(), this->GetJavaOption()->GetTypeDirectory(), L"VPGTypeBProperty.java"});
    
    VPGJavaGenerationService::GenerateEnum(this->GetLogConfig().get(), filePath1, L"", enumClassList1.at(0).get(), this->GetOption().get(), this->GetJavaOption().get());
    VPGJavaGenerationService::GenerateEnum(this->GetLogConfig().get(), filePath2, L"", enumClassList2.at(0).get(), this->GetOption().get(), this->GetJavaOption().get());
    
    EXPECT_TRUE(IsFileExists(filePath1));
    EXPECT_EQ(ReadFile(filePath1),
        L"package com.vcc.type;\r\n"
        "\r\n"
        "import java.util.Objects;\r\n"
        "\r\n"
        "public enum VPGTypeA {\r\n"
        "    EnumA(0),\r\n"
        "    EnumB(1),\r\n"
        "    EnumC(2);\r\n"
        "\r\n"
        "    public final Integer value;\r\n"
        "\r\n"
        "    VPGTypeA(Integer value) {\r\n"
        "        this.value = value;\r\n"
        "    }\r\n"
        "\r\n"
        "    public Integer getValue() {\r\n"
        "        return value;\r\n"
        "    }\r\n"
        "\r\n"
        "    public static VPGTypeA parse(Integer value) {\r\n"
        "        for (VPGTypeA type : values()) {\r\n"
        "            if (Objects.equals(type.value, value)) {\r\n"
        "                return type;\r\n"
        "            }\r\n"
        "        }\r\n"
        "        throw new IllegalArgumentException(\"Invalid VPGTypeA value: \" + value);\r\n"
        "    }\r\n"
        "\r\n"
        "}\r\n");

    EXPECT_TRUE(IsFileExists(filePath2));
    EXPECT_EQ(ReadFile(filePath2),
        L"package com.vcc.type;\r\n"
        "\r\n"
        "import java.util.Objects;\r\n"
        "\r\n"
        "public enum VPGTypeBProperty {\r\n"
        "    EnumA(0),\r\n"
        "    EnumB(1),\r\n"
        "    EnumC(999);\r\n"
        "\r\n"
        "    public final Integer value;\r\n"
        "\r\n"
        "    VPGTypeBProperty(Integer value) {\r\n"
        "        this.value = value;\r\n"
        "    }\r\n"
        "\r\n"
        "    public Integer getValue() {\r\n"
        "        return value;\r\n"
        "    }\r\n"
        "\r\n"
        "    public static VPGTypeBProperty parse(Integer value) {\r\n"
        "        for (VPGTypeBProperty type : values()) {\r\n"
        "            if (Objects.equals(type.value, value)) {\r\n"
        "                return type;\r\n"
        "            }\r\n"
        "        }\r\n"
        "        throw new IllegalArgumentException(\"Invalid VPGTypeBProperty value: \" + value);\r\n"
        "    }\r\n"
        "\r\n"
        "}\r\n");
}

TEST_F(VPGJavaGenerationServiceTest, GenerateObject)
{   
    std::wstring enumClass =
        L"#param once\r\n"
        "enum class VPGTypeBProperty {\r\n"
        "    Bool = 0, // GETSET(bool, Bool, false)\r\n"
        "    Long , // GETSET(long, Long, 0)\r\n"
        "    Float, // GETSET(float, Float, 0)\r\n"
        "    Char, // GETSET(char, Char, L'\\0')\r\n"
        "    WChar, // GETSET(wchar_t, WChar, L'\\0')\r\n"
        "    String, // GETSET(std::wstring, String, L\"\")\r\n"
        "    Enum, // GETSET(VPGTypeBProperty, Enum, VPGTypeBProperty::Bool)\r\n"
        "    Object = 50, // GETSET_SPTR_NULL(VPGTypeB, Object)\r\n"
        "    VectorDouble = 80, // VECTOR(double, VectorDouble)\r\n"
        "    VectorString, // VECTOR(std::wstring, VectorString)\r\n"
        "    Map, // MAP(int, double, Map)\r\n"
        "    OrderedMap, // ORDERED_MAP(int, double, OrderedMap\r\n"
        "    VectorObject, // VECTOR_SPTR(VPGTypeB, VectorObject)\r\n"
        "    MapObject, // MAP_SPTR_R(std::wstring, VPGTypeB, MapObject)\r\n"
        "    OrderedMapObject // ORDERED_MAP_SPTR_R(double, VPGTypeB, OrderedMapObject)\r\n" 
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::GetEnumClassReader()->Parse(enumClass, enumClassList);

    std::map<std::wstring, std::wstring> typeWorkspaceClassRelativePathMap;
    std::wstring filePath = ConcatPaths({this->GetWorkspace(), this->GetJavaOption()->GetObjectDirectory(), L"VPGTypeB.java"});
    VPGJavaGenerationService::GenerateObject(this->GetLogConfig().get(), filePath, L"", enumClassList.at(0).get(), typeWorkspaceClassRelativePathMap, typeWorkspaceClassRelativePathMap, this->GetOption().get(), this->GetJavaOption().get());
    
    EXPECT_TRUE(IsFileExists(filePath));
    EXPECT_EQ(ReadFile(filePath),
        L"package com.vcc.module;\r\n"
        "\r\n"
        "import com.sun.jna.Memory;\r\n"
        "import com.sun.jna.Native;\r\n"
        "import com.sun.jna.Pointer;\r\n"
        "import com.sun.jna.ptr.PointerByReference;\r\n"
        "import com.vcc.test.VPGDllFunctions;\r\n"
        "import com.vcc.type.VPGTypeBProperty;\r\n"
        "import java.util.HashSet;\r\n"
        "import java.util.Set;\r\n"
        "\r\n"
        "public class VPGTypeB {\r\n"
        "    public Pointer Handle = null;\r\n"
        "\r\n"
        "    public VPGTypeB(Pointer handle) {\r\n"
        "        this.Handle = handle;\r\n"
        "    }\r\n"
        "\r\n"
        "    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Properties\">\r\n"
        "    public boolean getBool() {\r\n"
        "        return VPGDllFunctions.Instance.ReadBool(Handle, VPGTypeBProperty.Bool.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setBool(boolean value) {\r\n"
        "        VPGDllFunctions.Instance.WriteBool(Handle, VPGTypeBProperty.Bool.getValue(), value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getLong() {\r\n"
        "        return VPGDllFunctions.Instance.ReadLong(Handle, VPGTypeBProperty.Long.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setLong(long value) {\r\n"
        "        VPGDllFunctions.Instance.WriteLong(Handle, VPGTypeBProperty.Long.getValue(), value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public float getFloat() {\r\n"
        "        return VPGDllFunctions.Instance.ReadFloat(Handle, VPGTypeBProperty.Float.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setFloat(float value) {\r\n"
        "        VPGDllFunctions.Instance.WriteFloat(Handle, VPGTypeBProperty.Float.getValue(), value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public byte getChar() {\r\n"
        "        return VPGDllFunctions.Instance.ReadChar(Handle, VPGTypeBProperty.Char.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setChar(byte value) {\r\n"
        "        VPGDllFunctions.Instance.WriteChar(Handle, VPGTypeBProperty.Char.getValue(), value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public char getWChar() {\r\n"
        "        return VPGDllFunctions.Instance.ReadWchar(Handle, VPGTypeBProperty.WChar.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setWChar(char value) {\r\n"
        "        VPGDllFunctions.Instance.WriteWchar(Handle, VPGTypeBProperty.WChar.getValue(), value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public String getString() {\r\n"
        "        PointerByReference result = new PointerByReference();\r\n"
        "        VPGDllFunctions.Instance.ReadString(Handle, VPGTypeBProperty.String.getValue(), result);\r\n"
        "        return result.getValue().getWideString(0);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setString(String value) {\r\n"
        "        Pointer valuePtr = new Memory(Native.WCHAR_SIZE * (value.length() + 1));\r\n"
        "        valuePtr.setWideString(0, value);\r\n"
        "        PointerByReference valueReference = new PointerByReference();\r\n"
        "        valueReference.setValue(valuePtr);\r\n"
        "        VPGDllFunctions.Instance.WriteString(Handle, VPGTypeBProperty.String.getValue(), valueReference);\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeBProperty getEnum() {\r\n"
        "        return VPGTypeBProperty.parse((int)VPGDllFunctions.Instance.ReadLong(Handle, VPGTypeBProperty.Enum.getValue()));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setEnum(VPGTypeBProperty value) {\r\n"
        "        VPGDllFunctions.Instance.WriteLong(Handle, VPGTypeBProperty.Enum.getValue(), value.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeB getObject() {\r\n"
        "        return new VPGTypeB(VPGDllFunctions.Instance.ReadObject(Handle, VPGTypeBProperty.Object.getValue()));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setObject(VPGTypeB value) {\r\n"
        "        VPGDllFunctions.Instance.WriteObject(Handle, VPGTypeBProperty.Object.getValue(), value.Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getVectorDoubleCount() {\r\n"
        "        return VPGDllFunctions.Instance.GetCount(Handle, VPGTypeBProperty.VectorDouble.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public double getVectorDoubleAtIndex(long index) {\r\n"
        "        return VPGDllFunctions.Instance.ReadDoubleAtIndex(Handle, VPGTypeBProperty.VectorDouble.getValue(), index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setVectorDoubleAtIndex(long index, double value) {\r\n"
        "        VPGDllFunctions.Instance.WriteDoubleAtIndex(Handle, VPGTypeBProperty.VectorDouble.getValue(), value, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertVectorDouble(double value) {\r\n"
        "        insertVectorDoubleAtIndex(-1, value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertVectorDoubleAtIndex(long index, double value) {\r\n"
        "        VPGDllFunctions.Instance.InsertDoubleAtIndex(Handle, VPGTypeBProperty.VectorDouble.getValue(), value, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeVectorDoubleAtIndex(long index) {\r\n"
        "        VPGDllFunctions.Instance.RemoveAtIndex(Handle, VPGTypeBProperty.VectorDouble.getValue(), index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearVectorDouble() {\r\n"
        "        VPGDllFunctions.Instance.Clear(Handle, VPGTypeBProperty.VectorDouble.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getVectorStringCount() {\r\n"
        "        return VPGDllFunctions.Instance.GetCount(Handle, VPGTypeBProperty.VectorString.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public String getVectorStringAtIndex(long index) {\r\n"
        "        PointerByReference result = new PointerByReference();\r\n"
        "        VPGDllFunctions.Instance.ReadStringAtIndex(Handle, VPGTypeBProperty.VectorString.getValue(), result, index);\r\n"
        "        return result.getValue().getWideString(0);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setVectorStringAtIndex(long index, String value) {\r\n"
        "        Pointer valuePtr = new Memory(Native.WCHAR_SIZE * (value.length() + 1));\r\n"
        "        valuePtr.setWideString(0, value);\r\n"
        "        PointerByReference valueReference = new PointerByReference();\r\n"
        "        valueReference.setValue(valuePtr);\r\n"
        "        VPGDllFunctions.Instance.WriteStringAtIndex(Handle, VPGTypeBProperty.VectorString.getValue(), valueReference, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertVectorString(String value) {\r\n"
        "        insertVectorStringAtIndex(-1, value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertVectorStringAtIndex(long index, String value) {\r\n"
        "        Pointer valuePtr = new Memory(Native.WCHAR_SIZE * (value.length() + 1));\r\n"
        "        valuePtr.setWideString(0, value);\r\n"
        "        PointerByReference valueReference = new PointerByReference();\r\n"
        "        valueReference.setValue(valuePtr);\r\n"
        "        VPGDllFunctions.Instance.InsertStringAtIndex(Handle, VPGTypeBProperty.VectorString.getValue(), valueReference, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeVectorStringAtIndex(long index) {\r\n"
        "        VPGDllFunctions.Instance.RemoveAtIndex(Handle, VPGTypeBProperty.VectorString.getValue(), index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearVectorString() {\r\n"
        "        VPGDllFunctions.Instance.Clear(Handle, VPGTypeBProperty.VectorString.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getMapCount() {\r\n"
        "        return VPGDllFunctions.Instance.GetCount(Handle, VPGTypeBProperty.Map.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public double getMapAtKey(int key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(int.class));\r\n"
        "        keyPtr.setInt(0, key);\r\n"
        "        return VPGDllFunctions.Instance.ReadDoubleAtKey(Handle, VPGTypeBProperty.Map.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setMapAtKey(int key, double value) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(int.class));\r\n"
        "        keyPtr.setInt(0, key);\r\n"
        "        VPGDllFunctions.Instance.WriteIntAtKey(Handle, VPGTypeBProperty.Map.getValue(), value, keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public Set<Integer> getMapKeys() {\r\n"
        "        Set<Integer> result = new HashSet<>();\r\n"
        "        Pointer ptrs = VPGDllFunctions.Instance.GetMapKeys(Handle, VPGTypeBProperty.Map.getValue());\r\n"
        "        long total = getMapCount();\r\n"
        "        for (var ptr : ptrs.getPointerArray(0)) {\r\n"
        "            if (ptr == null) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "            result.add(ptr.getInteger(0));\r\n"
        "            if (result.size() >= total) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "        }\r\n"
        "        return result;\r\n"
        "    }\r\n"
        "\r\n"
        "    public boolean isMapContainKey(int key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(int.class));\r\n"
        "        keyPtr.setInt(0, key);\r\n"
        "        return VPGDllFunctions.Instance.IsContainKey(Handle, VPGTypeBProperty.Map.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeMapAtKey(int key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(int.class));\r\n"
        "        keyPtr.setInt(0, key);\r\n"
        "        VPGDllFunctions.Instance.RemoveAtKey(Handle, VPGTypeBProperty.Map.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearMap() {\r\n"
        "        VPGDllFunctions.Instance.Clear(Handle, VPGTypeBProperty.Map.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getVectorObjectCount() {\r\n"
        "        return VPGDllFunctions.Instance.GetCount(Handle, VPGTypeBProperty.VectorObject.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeB getVectorObjectAtIndex(long index) {\r\n"
        "        return new VPGTypeB(VPGDllFunctions.Instance.ReadObjectAtIndex(Handle, VPGTypeBProperty.VectorObject.getValue(), index));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setVectorObjectAtIndex(long index, VPGTypeB value) {\r\n"
        "        VPGDllFunctions.Instance.WriteObjectAtIndex(Handle, VPGTypeBProperty.VectorObject.getValue(), value.Handle, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeB addVectorObject() {\r\n"
        "        return addVectorObjectAtIndex(-1);\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeB addVectorObjectAtIndex(long index) {\r\n"
        "        return new VPGTypeB(VPGDllFunctions.Instance.AddObjectAtIndex(Handle, VPGTypeBProperty.VectorObject.getValue(), VPGObjectType.TypeB.getValue(), index));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertVectorObject(VPGTypeB value) {\r\n"
        "        insertVectorObjectAtIndex(-1, value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertVectorObjectAtIndex(long index, VPGTypeB value) {\r\n"
        "        VPGDllFunctions.Instance.InsertObjectAtIndex(Handle, VPGTypeBProperty.VectorObject.getValue(), value.Handle, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeVectorObject(VPGTypeB value) {\r\n"
        "        VPGDllFunctions.Instance.RemoveObject(Handle, VPGTypeBProperty.VectorObject.getValue(), value.Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeVectorObjectAtIndex(long index) {\r\n"
        "        VPGDllFunctions.Instance.RemoveAtIndex(Handle, VPGTypeBProperty.VectorObject.getValue(), index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearVectorObject() {\r\n"
        "        VPGDllFunctions.Instance.Clear(Handle, VPGTypeBProperty.VectorObject.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getMapObjectCount() {\r\n"
        "        return VPGDllFunctions.Instance.GetCount(Handle, VPGTypeBProperty.MapObject.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeB getMapObjectAtKey(String key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.WCHAR_SIZE * (key.length() + 1));\r\n"
        "        keyPtr.setWideString(0, key);\r\n"
        "        return new VPGTypeB(VPGDllFunctions.Instance.ReadObjectAtKey(Handle, VPGTypeBProperty.MapObject.getValue(), keyPtr));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setMapObjectAtKey(String key, VPGTypeB value) {\r\n"
        "        Pointer keyPtr = new Memory(Native.WCHAR_SIZE * (key.length() + 1));\r\n"
        "        keyPtr.setWideString(0, key);\r\n"
        "        VPGDllFunctions.Instance.WriteObjectAtKey(Handle, VPGTypeBProperty.MapObject.getValue(), value.Handle, keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public Set<String> getMapObjectKeys() {\r\n"
        "        Set<String> result = new HashSet<>();\r\n"
        "        Pointer ptrs = VPGDllFunctions.Instance.GetMapKeys(Handle, VPGTypeBProperty.MapObject.getValue());\r\n"
        "        long total = getMapObjectCount();\r\n"
        "        for (var ptr : ptrs.getPointerArray(0)) {\r\n"
        "            if (ptr == null) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "            result.add(ptr.getWideString(0));\r\n"
        "            if (result.size() >= total) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "        }\r\n"
        "        return result;\r\n"
        "    }\r\n"
        "\r\n"
        "    public boolean isMapObjectContainKey(String key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.WCHAR_SIZE * (key.length() + 1));\r\n"
        "        keyPtr.setWideString(0, key);\r\n"
        "        return VPGDllFunctions.Instance.IsContainKey(Handle, VPGTypeBProperty.MapObject.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeMapObjectAtKey(String key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.WCHAR_SIZE * (key.length() + 1));\r\n"
        "        keyPtr.setWideString(0, key);\r\n"
        "        VPGDllFunctions.Instance.RemoveAtKey(Handle, VPGTypeBProperty.MapObject.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearMapObject() {\r\n"
        "        VPGDllFunctions.Instance.Clear(Handle, VPGTypeBProperty.MapObject.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getOrderedMapObjectCount() {\r\n"
        "        return VPGDllFunctions.Instance.GetCount(Handle, VPGTypeBProperty.OrderedMapObject.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    public double getOrderedMapObjectAtIndex(long index) {\r\n"
        "        return new double(VPGDllFunctions.Instance.ReadObjectAtIndex(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), index));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setOrderedMapObjectAtIndex(long index, double value) {\r\n"
        "        VPGDllFunctions.Instance.WriteObjectAtIndex(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), value.Handle, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public double addOrderedMapObject() {\r\n"
        "        return addOrderedMapObjectAtIndex(-1);\r\n"
        "    }\r\n"
        "\r\n"
        "    public double addOrderedMapObjectAtIndex(long index) {\r\n"
        "        return new double(VPGDllFunctions.Instance.AddObjectAtIndex(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), VPGObjectType.double.getValue(), index));\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGTypeB getOrderedMapObjectAtKey(double key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(double.class));\r\n"
        "        keyPtr.setDouble(0, key);\r\n"
        "        return new VPGTypeB(VPGDllFunctions.Instance.ReadObjectAtKey(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), keyPtr));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setOrderedMapObjectAtKey(double key, VPGTypeB value) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(double.class));\r\n"
        "        keyPtr.setDouble(0, key);\r\n"
        "        VPGDllFunctions.Instance.WriteObjectAtKey(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), value.Handle, keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertOrderedMapObject(double value) {\r\n"
        "        insertOrderedMapObjectAtIndex(-1, value);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void insertOrderedMapObjectAtIndex(long index, double value) {\r\n"
        "        VPGDllFunctions.Instance.InsertObjectAtIndex(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), value.Handle, index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public Set<Double> getOrderedMapObjectKeys() {\r\n"
        "        Set<Double> result = new HashSet<>();\r\n"
        "        Pointer ptrs = VPGDllFunctions.Instance.GetMapKeys(Handle, VPGTypeBProperty.OrderedMapObject.getValue());\r\n"
        "        long total = getOrderedMapObjectCount();\r\n"
        "        for (var ptr : ptrs.getPointerArray(0)) {\r\n"
        "            if (ptr == null) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "            result.add(ptr.getDouble(0));\r\n"
        "            if (result.size() >= total) {\r\n"
        "                break;\r\n"
        "            }\r\n"
        "        }\r\n"
        "        return result;\r\n"
        "    }\r\n"
        "\r\n"
        "    public boolean isOrderedMapObjectContainKey(double key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(double.class));\r\n"
        "        keyPtr.setDouble(0, key);\r\n"
        "        return VPGDllFunctions.Instance.IsContainKey(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeOrderedMapObjectAtIndex(long index) {\r\n"
        "        VPGDllFunctions.Instance.RemoveAtIndex(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), index);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void removeOrderedMapObjectAtKey(double key) {\r\n"
        "        Pointer keyPtr = new Memory(Native.getNativeSize(double.class));\r\n"
        "        keyPtr.setDouble(0, key);\r\n"
        "        VPGDllFunctions.Instance.RemoveAtKey(Handle, VPGTypeBProperty.OrderedMapObject.getValue(), keyPtr);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void clearOrderedMapObject() {\r\n"
        "        VPGDllFunctions.Instance.Clear(Handle, VPGTypeBProperty.OrderedMapObject.getValue());\r\n"
        "    }\r\n"
        "    // </editor-fold>\r\n"
        "}\r\n");
}

TEST_F(VPGJavaGenerationServiceTest, GenerateForm)
{
    std::wstring enumClass =
        L"#param once\r\n"
        "// @@Form\r\n"
        "enum class VPGGitFormProperty {\r\n"
        "    Log // GETSET_SPTR_NULL(VPGGitLog, Log)\r\n"
        "};\r\n";

    std::vector<std::shared_ptr<VPGEnumClass>> enumClassList;
    VPGGlobal::GetEnumClassReader()->Parse(enumClass, enumClassList);

    std::map<std::wstring, std::wstring> typeWorkspaceClassRelativePathMapObject, typeWorkspaceClassRelativePathMapForm;
    typeWorkspaceClassRelativePathMapObject.insert(std::make_pair(L"VPGGit", L"com.vcc.object"));
    std::wstring filePath = ConcatPaths({this->GetWorkspace(), this->GetJavaOption()->GetObjectDirectory(), L"VPGGitLog.java"});
    VPGJavaGenerationService::GenerateObject(this->GetLogConfig().get(), filePath, L"", enumClassList.at(0).get(), typeWorkspaceClassRelativePathMapObject, typeWorkspaceClassRelativePathMapForm, this->GetOption().get(), this->GetJavaOption().get());
    
    EXPECT_TRUE(IsFileExists(filePath));
    EXPECT_EQ(ReadFile(filePath),
        L"package com.vcc.form;\r\n"
        "\r\n"
        "import com.sun.jna.Pointer;\r\n"
        "import com.vcc.test.VPGDllFunctions;\r\n"
        //"import com.vcc.object.VPGGit;\r\n"
        "import com.vcc.type.VPGGitFormProperty;\r\n"
        "\r\n"
        "public class VPGGitForm {\r\n"
        "    public Pointer Handle = null;\r\n"
        "\r\n"
        "    public VPGGitForm(Pointer handle) {\r\n"
        "        this.Handle = handle;\r\n"
        "    }\r\n"
        "\r\n"
        "    public VPGGitForm() {\r\n"
        "        this.Handle = VPGDllFunctions.Instance.ApplicationCreateForm(VPGObjectType.GitForm.getValue());\r\n"
        "    }\r\n"
        "\r\n"
        "    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Properties\">\r\n"
        "    public VPGGitLog getLog() {\r\n"
        "        return new VPGGitLog(VPGDllFunctions.Instance.ReadObject(Handle, VPGGitFormProperty.Log.getValue()));\r\n"
        "    }\r\n"
        "\r\n"
        "    public void setLog(VPGGitLog value) {\r\n"
        "        VPGDllFunctions.Instance.WriteObject(Handle, VPGGitFormProperty.Log.getValue(), value.Handle);\r\n"
        "    }\r\n"
        "    // </editor-fold>\r\n"
        "\r\n"
        "    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Form Actions\">\r\n"
        "    public long clearAction() {\r\n"
        "        return VPGDllFunctions.Instance.ApplicationClearFormAction(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public void close(boolean isForce) {\r\n"
        "        VPGDllFunctions.Instance.ApplicationCloseForm(Handle, isForce);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getActionFirstSeqNo() {\r\n"
        "        return VPGDllFunctions.Instance.ApplicationGetFormActionFirstSeqNo(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long getActionLastSeqNo() {\r\n"
        "        return VPGDllFunctions.Instance.ApplicationGetFormActionLastSeqNo(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public boolean isClosable() {\r\n"
        "        return VPGDllFunctions.Instance.ApplicationIsFormClosable(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public boolean isClosed() {\r\n"
        "        return VPGDllFunctions.Instance.ApplicationIsFormClosed(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long redo(long noOfStep) {\r\n"
        "        return VPGDllFunctions.Instance.ApplicationRedoFormAction(Handle, noOfStep);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long redoToSeqNo(long seqNo) {\r\n"
        "        return VPGDllFunctions.Instance.ApplicationRedoFormActionToSeqNo(Handle, seqNo);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long truncateAction() {\r\n"
        "        return VPGDllFunctions.Instance.ApplicationTruncateFormAction(Handle);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long undo(long noOfStep) {\r\n"
        "        return VPGDllFunctions.Instance.ApplicationUndoFormAction(Handle, noOfStep);\r\n"
        "    }\r\n"
        "\r\n"
        "    public long undoToSeqNo(long seqNo) {\r\n"
        "        return VPGDllFunctions.Instance.ApplicationUndoFormActionToSeqNo(Handle, seqNo);\r\n"
        "    }\r\n"
        "    // </editor-fold>\r\n"
        "}\r\n");
}
